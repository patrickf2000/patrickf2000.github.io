<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Patrick's Website</title>
    <link rel="shortcut icon" type="image/png" href="patrickflynn.co/favicon.png">
    <link rel="shortcut icon" type="image/x-icon" href="patrickflynn.co/favicon.ico">
    <link rel="stylesheet" href="patrickflynn.co/theme/css/screen.css" type="text/css" />
    <link rel="stylesheet" href="patrickflynn.co/theme/css/pygments.css" type="text/css" />
    <link rel="stylesheet" href="patrickflynn.co/theme/css/print.css" type="text/css" media="print" />
    <meta name="generator" content="Pelican" />
    <meta name="description" content="" />
    <meta name="author" content="Patrick Flynn" />
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="patrickflynn.co/">Home</a></li>
                <li><a href="patrickflynn.co/contact-me/">Contact Me</a></li>
                <li><a href="patrickflynn.co/projects/">Projects</a></li>
                <li><a href="https://github.com/patrickf2000">GitHub</a></li>
                <li class="selected"><a href="patrickflynn.co/blog_index.html">Blog</a></li>
                <li><a href="patrickflynn.co/categories">Categories</a></li>
            </ul>
        </nav>
        <div class="header_box">
            <h1><a href="patrickflynn.co/">Patrick's Website</a></h1>
            <h2>Computers and life...</h2>
        </div>
    </header>
    <div id="wrapper">
        <div id="content">            <h4 class="date">Jan 03, 2021</h4>

            <article class="post">
                <h2 class="title">
                    <a href="patrickflynn.co/lila-v01.html" rel="bookmark" title="Permanent Link to &quot;Lila v0.1&quot;">Lila v0.1</a>
                </h2>

                
                

                <p>What's one of the coolest things you can do with computers? There are a lot of answers to this, but for me, its programming them in your own programming language.</p>
<p>The other day, I published my <a href="https://github.com/patrickf2000/lila">Lila</a> compiler and language, and today, some <a href="https://github.com/patrickf2000/lila-programs">example programs</a> (still a work in progress). Its not an official release; I published it because I felt like the syntax was concrete enough to safely do so. The compiler had been capable of doing some non-trivial things for a while now.</p>
<p>I'm not going to do a huge post on the language; I'll eventually write some documentation. I want to share some of the story behind it.</p>
<p>For the curious, here's a small example I wrote earlier. Basically, it calls "ls -l" in the current directory.</p>
<div class="highlight"><pre><span></span># An example of calling fork-exec on Linux

const int linux_fork = 57;
const int linux_exec = 59;

use std.text_io;
use std.os;

func main -&gt; int
    pid : int64 = 0;
    exe_args : str[3];
begin
    pid = fork();

    if pid == -1
        println(&quot;Error calling fork.&quot;);
        return pid;
    elif pid == 0
        exe_args[0] = &quot;/bin/ls&quot;;
        exe_args[1] = &quot;-l&quot;;
        exe_args[2] = 0;
        syscall(linux_exec, &quot;/bin/ls&quot;, exe_args, 0);

        println(&quot;Error&quot;);

        return 0;
    end

    return 0;
end
</pre></div>


<h3>Why Compilers?</h3>
<p>If you scroll through my Github profile, you will notice several compilers and other related tools (I think I have four compilers, an assembler, two VM programs, and a partial C parser on Github at the time of writing). I've been writing compilers for about a year and half now; if you include the interpreters, its probably been over two years. And I currently have a job working on a compiler. So yeah, its reasonable to infer I enjoy this field.</p>
<p>I enjoy this for a few reasons. First, I find programming languages really interesting. Take any compiled language- C, C++, Rust, D, Ada, Pascal, Haskell, Swift, OCaml, or anything else. I can use all these languages on the same computer, and they all compile to the same instructions and the same format. But the way you get work done in each is significantly different. And by virtue of that, each language is suitable for a certain domain. I find this really interesting. And for this reason, I've also enjoyed designing my own. And then implementing it.</p>
<p>Compilers are really interesting machines, and honestly one of the most underrated areas of computer science. Maybe because GCC scares a lot of people away. When you write a compiler, you basically create your own little world. You make the rules for the language, you decide what's right and wrong, and eventually, you decide how its translated and how the final instructions are generated. And once you get enough of the language implemented, you can create your own libraries, and eventually your own programs in your own language.</p>
<p>What is more cool than that?</p>
<h3>The Origins of Lila</h3>
<p>Earlier this year, I was working on two compilers: first, Quik 3, and second, extcc. The former was the last compiler I wrote for my Quik language, and the latter was a fork that was meant to be an extensible C compiler. Both got fairly far, and I'm still proud of them. But the reason I stopped was because I made some bad design choices early on, and because of the nature of C++, the only solution to fixing that was to basically start over.</p>
<p>And I did start over a few times. Originally, I wanted to make my own C compiler so I could have something with a small language surface I could hack. But let me be honest, I'm not a huge fan of C. Around this time, I began playing with Ada some, and I fell in love with it. I really like Ada and the Wirth-family of programming languages. Ada wasn't the only thing I tried; I was experimenting with other programming languages as well because I was getting tired of C++ and the issues that go with it. I'll save this exploration for a different post. But fast forward to September, I began looking at Rust again. I did a simple project to see if I could create the necessary IR's in Rust, and that project eventually evolved into Lila.</p>
<p>Lila wasn't originally the name. In fact, the Lila language is significantly different from when I started the project. Originally, the language was really close to Quik, and I named the project Dash (somewhat similar to Quik...). In November, I made the mistake of releasing it too soon; I didn't get much feedback, and when I started writing some simple programs in it, it became evident that it needed work. I took the project down, and began a significant redesign through late November and most of December. Originally, I wanted to name the language something different, but for certain reasons, I couldn't. Lila was fairly close to what I originally wanted to name it, and I like that name anyway.</p>
<p>Currently, this is my biggest project in terms of lines of code: a little under 9500 lines of Rust. The next biggest was extcc, which got to around 5000 I think. The project is honestly one of my favorite of all time.</p>
<h3>Some Features</h3>
<p>I'll save a lot of this for the documentation, but I just want to cover a few things here.</p>
<p>One of my favorite features is the array and string handling features. This has always been one of my biggest gripes with C. But I do not think the solution is to use a garbage collector. Basically, what I do is handle all memory allocations and deallocations at compile time. There is a statically-linked core library with (among other things) malloc and free functions, which are inserted by the compiler. So when you create an array, and leave a function, memory is allocated and deallocated behind the scenes.</p>
<p>Array sizes are stored next to the array pointers themselves, and can be retrieved at any point with the <code>sizeof</code> operator. This is especially useful in cases where you have to pass arrays to functions and for the for-each loops. There's also base utilities for managing strings in the core library. Strings are their own data types. At this point in history, I very strongly believe that strings should be an essential type of any language.</p>
<p>The syntax is inspired by the Wirth languages. Its still fairly verbose, but much less so than Pascal or Ada. Probably the most defining characteristic you will see is the variable block at the top of each function. I really like this, and I believe it encourages better programming. Rather than strewing variables all over the place, you can see all your variables and manage them accordingly.</p>
<p>As far as architectures go, x86-64 is fully supported, and RISC-V supports a lot of the integer-related elements. The basic hello-world Arm64 tests pass, but that's about it. Lila is meant to be easy to port to other architectures, which is something I plan on doing in the near future. I also have a fairly decent standard library underway. Text IO functions such as printf and console input are supported, a few string functions, file functions, and OS functions are all supported. One of the things I got working today was process management (fork and exec on Linux).</p>
<h3>Conclusion</h3>
<p>I'll write more as interesting progress is made. In the immediate future, I plan on working on the standard library and just general testing by writing some non-trivial programs. If you decide the try it out, please let me know how it goes!</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="patrickflynn.co/lila-v01.html">posted at 19:38</a>
                    &nbsp;&middot;&nbsp;<a href="patrickflynn.co/category/lila.html" rel="tag">Lila</a>
                </div>
            </article>            <h4 class="date">Dec 31, 2020</h4>

            <article class="post">
                <h2 class="title">
                    <a href="patrickflynn.co/moving-to-github.html" rel="bookmark" title="Permanent Link to &quot;Moving to Github&quot;">Moving to Github</a>
                </h2>

                
                

                <p>This post is actually a little overdue. I did this about a month ago, I just never had gotten around to writing it...</p>
<p>A few months ago, I wrote a post on my overall website structure. That since has changed. But for those who didn't see it, I will briefly cover it.</p>
<h3>In The Beginning...</h3>
<p>I've been in and out of blogging for about a year and a half now. Originally, I created a Wordpress blog. I had to buy hosting from a company, and it really wasn't that expensive at the time. Fast forward a year later, I didn't feel like it had gotten anywhere, and when renewal came around, it was like double what it was originally. So yeah, couldn't afford that.</p>
<p>I looked at some other hosting providers, but then I read about static websites. I've known about those for a while, but I didn't know much about static site generators. A few similar blogs that I followed used them, and they looked really nice, so I decided to give it a try. There are several out there, but the one I use is called <a href="https://docs.getpelican.com/en/stable/">Pelican</a>. Its really easy to use and configure, and there are plenty of themes. I actually really like how I can write my pages and posts in Markdown, and then just push it when I'm ready to publish.</p>
<p>For hosting, this site has actually moved around three times now. I originally used Surge (surge.sh), and it worked really well, but I didn't like how you had to upgrade to get HTTPS support. Also, when I installed surge on my Linux system, it dragged in a lot of crap. Pelican only uses Python, which I have anyway, so I don't mind that so much. After that, I moved it over to Gitlab. And then a month ago, I moved it to Github.</p>
<p>The reason for the second move was because the website is important to me, but the Gitlab account is not. I use Gitlab for smaller or half-finished projects that I don't really care about. All my important stuff is on Github, in part because I've used it for all my computer science jobs. I personally think getting Github to work is easier than surge or Gitlab.</p>
<h3>Setting Up Github</h3>
<p>Github's website hosting is called Github Pages. To create a pages site, simply create a repository named <code>&lt;your username&gt;.github.io</code>:</p>
<p><img alt="Photo" src="patrickflynn.co/images/github_header.png"></p>
<p>The initial address of your site will be (in my case) "patrickf2000.github.io". Anything in the master branch will be hosted as the website.</p>
<p>I already had a custom domain that I wanted to use; the good news is that Github lets you do that as well. In my opinion, this is the hardest part. Github has better documentation than I could provide on the subject, but basically the gist is that you change it in the repository's settings, and then update the DNS settings for whoever your domain provider is.</p>
<p>For the curious, I use Namecheap for my domain name. As the name implies, its cheap... Yeah. I only pay like $10 yearly for it. Some of their names are cheaper than that.</p>
<h3>Publishing</h3>
<p>The master branch cannot contain anything except the website- so in my case, the output of Pelican. Ideally though, you would want to store your sources, so there is two ways you can do that. The first is to create a separate repository; the second is to create a branch.</p>
<p>For my site, I have the master branch which has the site output, and a branch named <code>sources</code> which contains the Markdown and Pelican configuration. On my computer, I have two folders, one for each branch (you can do that...). In the sources folder, I write my post or update whatever, and then use a script to copy the output to the folder set on the master branch. It's really easy actually.</p>
<p>Here's the script; it will work on Linux and Mac OS. Windows users, you're on your own :)</p>
<div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>

rm -rf ./output 
pelican content

rm -r ../patrickf2000.github.io/*
cp -r ./output/* ../patrickf2000.github.io
cp CNAME ../patrickf2000.github.io

<span class="nb">cd</span> ../patrickf2000.github.io
git add .
git commit
git push -u origin master

<span class="nb">echo</span> <span class="s2">&quot;Done&quot;</span>
</pre></div>


<p>If you want to automate the process even further, you can change the line that says <code>git commit</code> to something like <code>git commit -m "Post update"</code>. In my case, I actually care about commit messages, so this forces me to write one.</p>
<h3>Conclusion</h3>
<p>As you can see, publishing a simple blog that still looks nice is really easy. The only thing I haven't figured out is how to get Google Analytics working so I can track page views. (I do care about privacy, but I also am curious if anyone actually looks at this). If you know how, let me know.</p>
<p>Finally, everything is public on Github, so feel free to look through the sources if you're curious about setting something similar up.</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="patrickflynn.co/moving-to-github.html">posted at 08:00</a>
                    &nbsp;&middot;&nbsp;<a href="patrickflynn.co/category/blogging.html" rel="tag">Blogging</a>
                </div>
            </article>            <h4 class="date">Dec 30, 2020</h4>

            <article class="post">
                <h2 class="title">
                    <a href="patrickflynn.co/corelib-vs-nolib.html" rel="bookmark" title="Permanent Link to &quot;Corelib vs Nolib&quot;">Corelib vs Nolib</a>
                </h2>

                
                

                <p>I've been working on my new programming language and compiler quite a bit over the past two weeks since school has finished. This is an idea I've been working on... I don't know, maybe someone will find this interesting.</p>
<p>One of the goals of my new language is to create a safe environment, meaning (among other things) the programmer doesn't have to worry about things like allocation and deallocation. That is a big problem with C in that you have to remember to deallocate anything you allocate. It makes sense, and in some cases you need this level of control, but for your average userspace application, its so easy to forget this extra step. And when you do, bad things happen.</p>
<p>Originally, my approach was to use Linux system calls. I figured out how to allocate and free memory using the mmap syscall; when the compiler did not use the C library, it would generate this call. You can probably see the problem with this however: its not portable. I also had this problem in a few other areas. For instance, when the program exists, everything needs to be deallocated first (the approach was similar: have a keyword for exit, then generate a system call). Strings were the most problematic. There's no system call for that, and it would be way to complicated to arbitrarily generate code for a string comparison or a string length function (another goal is to make string handling builtin and much easier to work with).</p>
<p>A standard library like most languages have is a good idea, but if its not on the user's system, or its the wrong version, or whatever, bad things can happen.</p>
<p>I think a good compromise around this is to have two libraries: a core library, and a standard library.</p>
<h3>Nolib</h3>
<p>Nolib (aka, no library) is the C approach. In some cases, it makes sense to have absolutely no overhead. A good case is with operating systems or stuff that interacts directly with the hardware. But when it comes to userland, having no easy library is the wrong approach.</p>
<p>This is basically the reason why I don't love using C, especially for compiler work. A lot of what I like to do deals with parsing strings, which can really be a pain in C. The C library has some basic functions to get you started, but when it comes to resizing and all that, its just too much.</p>
<h3>What About Go?</h3>
<p>Go's approach is to statically link the entire standard library to the smallest application.</p>
<p>This is a <em>horrible</em> idea.</p>
<p>If you look at Go's standard library, it has a lot of stuff. Everything from dealing with different types of text to compressed archives to networking. If I'm writing a compiler, I don't need the networking interface compiled into the executable. This approach results in huge executables. On the upside, you never have to worry about DLL hell and APIs breaking, but honestly, when it comes to a programming language's standard library, you really shouldn't have this issue.</p>
<h3>The Corelib</h3>
<p>As I said, the approach I'm trying out is to create a core library and a standard library. I'm sure I'm not the inventor of this, but off the top of my head, I can't think of anything that does this. Here's the idea.</p>
<p>The core library contains the most basic functions, such as malloc, free, strcmp, strlen, exit, and maybe a printing function (for just strings, not printf). These functions are all small and self-contained. The string functions are written purely in the implementation language. All the others make appropriate system calls (so they are basically just wrappers). There is header that defines all the system call numbers for the current architecture, which can be conditionally included.</p>
<p>The core library is built as a static library; that way, any library or executable will have these basic functions already in them. It may create slightly larger binaries, but in today's world the extra space is negligible (especially if Go is a good idea...). It would also be faster since you don't have the extra step of dynamically loading a library.</p>
<p>The standard library contains all the nice functions like printf, string conversion, file system, and so forth. This is built as a shared library since it will probably get to be pretty big.</p>
<h3>Static vs Shared Libraries</h3>
<p>So what's the difference between a static and a shared library?</p>
<p>A static library is compiled into the executable when it is linked. When you build the static library, you are basically just creating an archive of the object files, which are copied into the user's executable when it is built.</p>
<p>A shared library is a separate entity on the disk. When the executable is built, information is included that points to the shared libraries location. When the program is run, both the program and the shared library are loaded into memory, and any linkages are resolved.</p>
<h3>Conclusion</h3>
<p>As I said at the beginning, this post was meant to be more of random thought. My current project has been an interesting journey, especially now that I'm at the stage where I can start implementing the core libraries. When you get to that point, you know you've come a long way :)</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="patrickflynn.co/corelib-vs-nolib.html">posted at 08:00</a>
                    &nbsp;&middot;&nbsp;<a href="patrickflynn.co/category/compilers.html" rel="tag">Compilers</a>
                </div>
            </article>            <h4 class="date">Dec 13, 2020</h4>

            <article class="post">
                <h2 class="title">
                    <a href="patrickflynn.co/memory-and-counting-in-hardware.html" rel="bookmark" title="Permanent Link to &quot;Memory and Counting in Hardware&quot;">Memory and Counting in Hardware</a>
                </h2>

                
                

                <p>Electronics have been a secondary hobby of mine for a little while now... though I admit, I'm not too great at it. Actually, its more like an on-and-off thing. I'm trying to make it more of an on thing because its an interesting thing to do. I've written a few posts here on VHDL, which is a start.</p>
<p>Depending on what you want to do, having some sort of memory is an ideal start. I don't have any memory elements other than shift registers, but they can be used like regular set-and-release memory just as easily. And the other nice thing about them is that you can chain them together, which means you can basically make your memory as big or small as you want. For a starter project, I made a 16-bit binary counter. Okay, its really not <em>that</em> impressive; basically, the microcontroller does the counting and math, and the shift registers and a bunch of LED's are used to display the current number.</p>
<p>Here's an image of it running:</p>
<p><img alt="Photo" src="patrickflynn.co/images/arduino_counter.jpg"></p>
<p>Know what the number is? 663. 2^9 + 2^7 + 2^4 + 2^2 + 2^1 + 2^0 = 663. The counter is big-endian.</p>
<p>And for the curious, that's a cell phone charger powering it. Yes, I had to program it at my computer, but the computer was in a room with horrible lighting.</p>
<p>Okay, so as far as parts list goes, here's what I used:   </p>
<ul>
<li>Arduino- any model is fine, but I only have a Micro   </li>
<li>(x2) SN74HC595N (8-bit shift register)   </li>
<li>(x16) LED lights   </li>
<li>(x16) 220 ohm resistors (this doesn't have to be exact, but it shouldn't be much if any lower)   </li>
<li>Wires   </li>
</ul>
<p>As you can see, I have two types of wire- the regular jumper wires and some thicker doorbell wire. The doorbell wire is great. Its not too hard to work with, and you can buy this huge strand from Lowe's for $10 that will last forever.</p>
<h3>Building the Circuit</h3>
<p>Here's a diagram of the shift register pinout:</p>
<p><img alt="Photo" src="patrickflynn.co/images/74HC595_pinout.png"></p>
<p>Unfortunately, I don't have a drawing or anything of my circuit, so I will describe it as best as I can.</p>
<p>For the first shift register:</p>
<ul>
<li>Connect VCC and GND to voltage and ground, respectively   </li>
<li>Connect OE to to ground   </li>
<li>Connect SRCLR to voltage   </li>
<li>Connect SER to the arduino (on mine, its pin 2). This is the data pin.   </li>
<li>Connect RCLK to the arduino (on mine, pin 3). This is the latch pin.   </li>
<li>Connect SRCLK to the arduino (on mine, pin 4). This is the clock pin.   </li>
</ul>
<p>The second shift register is similar. But because we want to control both at once, there are a few important differences.</p>
<ul>
<li>Connect SER to the Qh' pin on the first register   </li>
<li>Connect the RCLK and SRCLK to the RCLK and SRCLK of the first register   </li>
</ul>
<p>On both registers, pins Qa - Qh will connect to LEDs. The overall connect for the LEDs will be <code>shift register pin -&gt; resistor -&gt; LED -&gt; ground</code>.</p>
<h3>Programming</h3>
<p>I'm going to assume you know the basics of Arduino programming. If you have the program installed and know you to compile and upload the example program for making the onboard LED blink, you're good to continue.</p>
<p>I'll post the entire code on another page, but this is the general idea for programming a shift register. A single shift register works with 1 byte, or 8 bits, which corresponds to the <code>byte</code> type in the Arduino language.</p>
<ol>
<li>Set the latch pin to 0.   </li>
<li>Enter a loop and write out the byte of data.   </li>
<li>Set the latch pin to 1.   </li>
</ol>
<p>And the algorithm for the loop is (each loop iteration):</p>
<ol>
<li>Set the clock pin to low.   </li>
<li>Set the data pin to the current bit. The current bit is the <code>data &amp; (1 &lt;&lt; i)</code> where <code>data</code> is your byte value, and <code>i</code> is your loop index.   </li>
<li>Set the clock pin to high.   </li>
<li>Set the data pin to low (so we can have a stable signal).   </li>
</ol>
<p>The principle is exactly the same whether you have one shift register or 10. In our case we have two, which means we can display 16 bits of data, which corresponds to a <code>short</code> in the Arduino language (and all other languages that have it...). The easiest way to do this is first put the algorithm in a separate function, which we will call <code>writeOut(byte shiftData)</code>. Then, after you set the latch pin to 0, make two calls to <code>writeOut</code>, the first call with one half of the data, the second call with the other half. Then raise the latch pin. Both shift registers will be populated. If you have 10 shift registers, you would make 10 function calls in between lowering and raising the latch.</p>
<p>If you're wondering about order, think of it as a top-down thing. The first function call will the be the last shift register, and the last function call will be the first shift register. Get it? Shift register...</p>
<p>Okay. Here's the code. I put it on a separate page since its long. You can find it <a href="pages/shift-register-program.html">here</a>.</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="patrickflynn.co/memory-and-counting-in-hardware.html">posted at 12:15</a>
                    &nbsp;&middot;&nbsp;<a href="patrickflynn.co/category/electronics.html" rel="tag">Electronics</a>
                </div>
            </article>            <h4 class="date">Dec 09, 2020</h4>

            <article class="post">
                <h2 class="title">
                    <a href="patrickflynn.co/vintage-os.html" rel="bookmark" title="Permanent Link to &quot;Vintage OS&quot;">Vintage OS</a>
                </h2>

                
                

                <p>So I was cleaning house earlier... Or rather, cleaning the computer. You know, when there gets to be a million things on your desktop? Anyway.</p>
<p>I have a small collection of vintage operating systems, some of which I've been able to get running in virtual machines. When I say vintage, I don't necessarily mean the ones everyone has heard about; there's a few obscure you may never have heard of. But anyway, I forgot I had screenshots of them because they are with the OSes and not the rest of my pictures. I only have three OSes photographed at the moment, but they are worth seeing.</p>
<h2>IBM OS/2</h2>
<p>The only truly vintage one here. The history behind this operating system is interesting. It runs without any issues in Virtualbox, but as I remember it was a little tricky to get running. I lost the article, but if I ever decide to run it again, I'll be sure to post.</p>
<p><img alt="Photo" src="patrickflynn.co/images/os2.png"></p>
<h2>Sky OS</h2>
<p>Sky OS was a fairly complete operating system written mainly by Robert Szeleney from 1997 until 2009. It was a Unix-like OS with a graphical desktop, and even got to the point of being able to run real applications such as the GNU Toolchain and Firefox. The OS was meant to be a commerical product, but it never aquired a sufficient developer/user base, and eventually, Szeleney couldn't keep up with development. You can still find disk images and a key and boot it up in Virtualbox. Its a rather nice OS, its a shame it never went further.</p>
<p>The desktop:</p>
<p><img alt="Photo" src="patrickflynn.co/images/skyos1.png"></p>
<p>Some applications running:</p>
<p><img alt="Photo" src="patrickflynn.co/images/skyos2.png"></p>
<h2>Syllable OS</h2>
<p>Another free OS from the early 2000s. Unlike Sky OS, Syllable was actually open source. It eventually stagnated and development ended in 2012. There wasn't a huge team behind this one either, and it got really far in terms of capabilities. Its a shame neither this nor Sky OS ever became viable alternatives to Windows because they really had potential.</p>
<p>The desktop:</p>
<p><img alt="Photo" src="patrickflynn.co/images/syllable1.png"></p>
<p>The file explorer:</p>
<p><img alt="Photo" src="patrickflynn.co/images/syllable2.png"></p>
                <div class="clear"></div>

                <div class="info">
                    <a href="patrickflynn.co/vintage-os.html">posted at 12:30</a>
                    &nbsp;&middot;&nbsp;<a href="patrickflynn.co/category/random.html" rel="tag">Random</a>
                </div>
            </article>

                <div class="clear"></div>
                <div class="pages">

                    <a href="patrickflynn.co/blog_index2" class="next_page">Next&nbsp;&rarr;</a>
                    <span>Page 1 of 5</span>
                </div>

            <div class="clear"></div>
            <footer>
                <p>
                <a href="https://github.com/jody-frankowski/blue-penguin">Blue Penguin</a> Theme
                &middot;
                Powered by <a href="http://getpelican.com">Pelican</a>
            </footer>
        </div>
        <div class="clear"></div>
    </div>
    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-213498014-7");
    pageTracker._trackPageview();
    } catch(err) {}</script>
</body>
</html>
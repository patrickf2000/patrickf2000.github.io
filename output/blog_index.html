<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Patrick's Website</title>
    <link rel="shortcut icon" type="image/png" href="/favicon.png">
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
    <link rel="stylesheet" href="/theme/css/screen.css" type="text/css" />
    <link rel="stylesheet" href="/theme/css/pygments.css" type="text/css" />
    <link rel="stylesheet" href="/theme/css/print.css" type="text/css" media="print" />
    <meta name="generator" content="Pelican" />
    <meta name="description" content="" />
    <meta name="author" content="Patrick Flynn" />
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="/">Home</a></li>
                <li><a href="/pages/contact-me.html">Contact Me</a></li>
                <li><a href="/pages/projects.html">Projects</a></li>
                <li><a href="https://github.com/patrickf2000">GitHub</a></li>
                <li class="selected"><a href="/blog_index.html">Blog</a></li>
                <li><a href="/categories">Categories</a></li>
            </ul>
        </nav>
        <div class="header_box">
            <h1><a href="/">Patrick's Website</a></h1>
            <h2>Computers and life...</h2>
        </div>
    </header>
    <div id="wrapper">
        <div id="content">            <h4 class="date">Jan 30, 2021</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/raspberry-pi-router.html" rel="bookmark" title="Permanent Link to &quot;Raspberry Pi Router&quot;">Raspberry Pi Router</a>
                </h2>

                
                

                <p>I heard a while back from a friend that a Raspberry Pi can be used as a router. I never really thought about it until last December, when I was trying to find a more useful anti-distraction method than my browser blocker (it was too easy to get around). I found some guides on how you can use a Raspberry Pi to create a wireless access point within your home network, and from there install a DNS blackhole which can be used to block a lot of things.</p>
<p>I originally set things up and ran it on a Rasberry Pi 3B+, and it ran for the last 15 days or so of December. Then at the beginning of the year, I took it down and moved everything over to a Raspberry Pi 4. As of today, the Pi 4 has been happily running without a reboot for 28 days (which is now my personal record for the longest uptime of any computer).</p>
<p>Here's it running:</p>
<p><img alt="Photo" src="/images/rpi.jpg"></p>
<p>An anti-distraction mechanism? Doesn't that seem like an extreme method?</p>
<p>Yes. But its worth it. Even though I love what I do, its just too easy to get distracted when you're researching things. And it can become damaging if you let it happen unchecked too often. If you don't believe me, read <em>The Shallows</em> by Nicholas Carr.</p>
<p>But seriously though, its super easy to set up, even for a non-technical person, and it actually works. I can safely say this because system and network administration is not one of my strong points in computer science. The DNS blackhole I talked about is called Pi-Hole. Its actually used to block advertistements, but because of how it functions, its equally as well suited as a site blocker. And as far as speed goes, I really don't notice a difference from my home network. Downloads are slightly slower, but its not huge. Uploads aren't bad at all. I have Zoom meetings regularly with it, and again, no issues.</p>
<p>If you're interested, I have instructions on my site for setting it up: <a href="/howto/rpi-router.html">Raspberry Pi Router</a></p>
                <div class="clear"></div>

                <div class="info">
                    <a href="/raspberry-pi-router.html">posted at 09:30</a>
                    &nbsp;&middot;&nbsp;<a href="/category/random.html" rel="tag">Random</a>
                </div>
            </article>            <h4 class="date">Jan 29, 2021</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/hi-tech-02-ranger.html" rel="bookmark" title="Permanent Link to &quot;Hi-Tech '02 Ranger&quot;">Hi-Tech '02 Ranger</a>
                </h2>

                
                

                <p>I drive a 2002 Ford Ranger, and I have been for over a year now (I bought it back in summer 2019). </p>
<p><img alt="Photo" src="/images/ranger.jpg"></p>
<p>Rangers are great cars for people who like to drive trucks but don't want something huge. One of my few gripes with it was the radio system. It wasn't completely awful- it was actually an upgrade from my first car, a 2001 Ford Expedition (it was actually my dad's). Because of the Expedition, I've never been able to use my phone- I use CDs. But even though the Ranger can play more CDs, it struggles to actually play them.</p>
<p>So, for my birthday, I got an upgrade. And I tried to install it myself, and I got as far as getting the old one out:</p>
<p><img alt="Photo" src="/images/radio-attempt.jpg"></p>
<p>Being the mechanical genius I am, it never occurred to me that you needed an adaptor for the connectors. I don't know, I thought they were all the same... But it turned out that Best Buy where my dad bought the radio had free installation, so I went there yesterday and had someone who knew what they were doing install it.</p>
<p>And its <em>awesome</em>. In addition to CDs and radio, it has Bluetooth, AUX plugin, and a USB charger. And because the radio was a little small, they used a mounting kit, so there's a little slot below, which will be nice for storing things... Just look below :)</p>
<p><img alt="Photo" src="/images/new-radio.jpg"></p>
                <div class="clear"></div>

                <div class="info">
                    <a href="/hi-tech-02-ranger.html">posted at 07:30</a>
                    &nbsp;&middot;&nbsp;<a href="/category/random.html" rel="tag">Random</a>
                </div>
            </article>            <h4 class="date">Jan 18, 2021</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/book-review-unix-a-history-and-a-memoir.html" rel="bookmark" title="Permanent Link to &quot;Book Review: "Unix: A History and a Memoir"&quot;">Book Review: "Unix: A History and a Memoir"</a>
                </h2>

                
                

                <p>Last week, I stumbled upon this very recently published book (2019) by Brian Kernighan. It was a short read, but one I vastly enjoyed. The book is about the evolution of Unix and the accompanying languages and tools which basically shaped the entire field of computer science as we know it today. In addition to providing valuable Unix history, its also a memoir on Kernighan's time at Bell Labels.</p>
<p>I'm not going to tell the story, but I will provide some background.</p>
<p>Bell Labs was AT&amp;T's research arm through much of the 1900s. Because of AT&amp;T's interest in computerizing elements of the telephone system, an enormous amount of computer innovation originated here (along with innovation in many other fields). Because of the lab's size and environment, innovation flourished that benefited many areas beyond AT&amp;T. Bell Labs was broken up with AT&amp;T in the 1980s and 90s, but still exists today as Nokia Bell Labs.</p>
<p>Unix is the grandfather of the majority of operating systems today, which includes Linux, MacOS, iOS, Android, the BSDs, and the commercial systems like Solaris and HP-UX- basically everything except Windows and DOS. The birth of Unix basically led to the birth of computer as we know it today, and many of the tools we take for granted, such as the C language and compilers, programmable shells like Bash, tools like make, cat, grep, and many, many others. Unix (and C for that matter) were so successful because of their highly innovate yet simple design; Unix provides building blocks which allow for very complex yet manageable systems to be created.</p>
<p>The history of computer science, and especially Unix, has always intrigued me. And honestly, this is one of the best histories I've read of this period. I think the design principles that went into Unix, C, and other tools are very underappreciated and under taught. Good software does not equal more features, and high productivity does not equal more lines of code. Good software uses a simple approach, reduces special cases, and doesn't have bloat or useless features. And when I say simple, that does not mean easy. Creating a simple design like Unix's is hard and requires genius (something its original creators, Ken Thompson and Dennis Richie had).</p>
<p>The other thing I really liked was how much Kernighan described the working environment at Bell Labs. There is a lot of discussion on productivity and collaboration in this day and age, and I think that the environment at Bell Labs captures the ideal scenario- allowing for long-term thinking, and a physical layout that encourages encounters and collaborations, but still gives the researchers their own private space to think and work quietly. In other words, the obsession with quarterly progress and constant collaboration needs to go.</p>
<p>This is certainly one of the better memoirs I've read in a while, and I highly recommend anyone in a technical field to read it. If you're in computer science, I especially recommend it. You should know your history :)</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="/book-review-unix-a-history-and-a-memoir.html">posted at 07:09</a>
                    &nbsp;&middot;&nbsp;<a href="/category/books.html" rel="tag">Books</a>
                </div>
            </article>            <h4 class="date">Jan 03, 2021</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/lila-v01.html" rel="bookmark" title="Permanent Link to &quot;Lila v0.1&quot;">Lila v0.1</a>
                </h2>

                
                

                <p>What's one of the coolest things you can do with computers? There are a lot of answers to this, but for me, its programming them in your own programming language.</p>
<p>The other day, I published my <a href="https://github.com/patrickf2000/lila">Lila</a> compiler and language, and today, some <a href="https://github.com/patrickf2000/lila-programs">example programs</a> (still a work in progress). Its not an official release; I published it because I felt like the syntax was concrete enough to safely do so. The compiler had been capable of doing some non-trivial things for a while now.</p>
<p>I'm not going to do a huge post on the language; I'll eventually write some documentation. I want to share some of the story behind it.</p>
<p>For the curious, here's a small example I wrote earlier. Basically, it calls "ls -l" in the current directory.</p>
<div class="highlight"><pre><span></span># An example of calling fork-exec on Linux

const int linux_fork = 57;
const int linux_exec = 59;

use std.text_io;
use std.os;

func main -&gt; int
    pid : int64 = 0;
    exe_args : str[3];
begin
    pid = fork();

    if pid == -1
        println(&quot;Error calling fork.&quot;);
        return pid;
    elif pid == 0
        exe_args[0] = &quot;/bin/ls&quot;;
        exe_args[1] = &quot;-l&quot;;
        exe_args[2] = 0;
        syscall(linux_exec, &quot;/bin/ls&quot;, exe_args, 0);

        println(&quot;Error&quot;);

        return 0;
    end

    return 0;
end
</pre></div>


<h3>Why Compilers?</h3>
<p>If you scroll through my Github profile, you will notice several compilers and other related tools (I think I have four compilers, an assembler, two VM programs, and a partial C parser on Github at the time of writing). I've been writing compilers for about a year and half now; if you include the interpreters, its probably been over two years. And I currently have a job working on a compiler. So yeah, its reasonable to infer I enjoy this field.</p>
<p>I enjoy this for a few reasons. First, I find programming languages really interesting. Take any compiled language- C, C++, Rust, D, Ada, Pascal, Haskell, Swift, OCaml, or anything else. I can use all these languages on the same computer, and they all compile to the same instructions and the same format. But the way you get work done in each is significantly different. And by virtue of that, each language is suitable for a certain domain. I find this really interesting. And for this reason, I've also enjoyed designing my own. And then implementing it.</p>
<p>Compilers are really interesting machines, and honestly one of the most underrated areas of computer science. Maybe because GCC scares a lot of people away. When you write a compiler, you basically create your own little world. You make the rules for the language, you decide what's right and wrong, and eventually, you decide how its translated and how the final instructions are generated. And once you get enough of the language implemented, you can create your own libraries, and eventually your own programs in your own language.</p>
<p>What is more cool than that?</p>
<h3>The Origins of Lila</h3>
<p>Earlier this year, I was working on two compilers: first, Quik 3, and second, extcc. The former was the last compiler I wrote for my Quik language, and the latter was a fork that was meant to be an extensible C compiler. Both got fairly far, and I'm still proud of them. But the reason I stopped was because I made some bad design choices early on, and because of the nature of C++, the only solution to fixing that was to basically start over.</p>
<p>And I did start over a few times. Originally, I wanted to make my own C compiler so I could have something with a small language surface I could hack. But let me be honest, I'm not a huge fan of C. Around this time, I began playing with Ada some, and I fell in love with it. I really like Ada and the Wirth-family of programming languages. Ada wasn't the only thing I tried; I was experimenting with other programming languages as well because I was getting tired of C++ and the issues that go with it. I'll save this exploration for a different post. But fast forward to September, I began looking at Rust again. I did a simple project to see if I could create the necessary IR's in Rust, and that project eventually evolved into Lila.</p>
<p>Lila wasn't originally the name. In fact, the Lila language is significantly different from when I started the project. Originally, the language was really close to Quik, and I named the project Dash (somewhat similar to Quik...). In November, I made the mistake of releasing it too soon; I didn't get much feedback, and when I started writing some simple programs in it, it became evident that it needed work. I took the project down, and began a significant redesign through late November and most of December. Originally, I wanted to name the language something different, but for certain reasons, I couldn't. Lila was fairly close to what I originally wanted to name it, and I like that name anyway.</p>
<p>Currently, this is my biggest project in terms of lines of code: a little under 9500 lines of Rust. The next biggest was extcc, which got to around 5000 I think. The project is honestly one of my favorite of all time.</p>
<h3>Some Features</h3>
<p>I'll save a lot of this for the documentation, but I just want to cover a few things here.</p>
<p>One of my favorite features is the array and string handling features. This has always been one of my biggest gripes with C. But I do not think the solution is to use a garbage collector. Basically, what I do is handle all memory allocations and deallocations at compile time. There is a statically-linked core library with (among other things) malloc and free functions, which are inserted by the compiler. So when you create an array, and leave a function, memory is allocated and deallocated behind the scenes.</p>
<p>Array sizes are stored next to the array pointers themselves, and can be retrieved at any point with the <code>sizeof</code> operator. This is especially useful in cases where you have to pass arrays to functions and for the for-each loops. There's also base utilities for managing strings in the core library. Strings are their own data types. At this point in history, I very strongly believe that strings should be an essential type of any language.</p>
<p>The syntax is inspired by the Wirth languages. Its still fairly verbose, but much less so than Pascal or Ada. Probably the most defining characteristic you will see is the variable block at the top of each function. I really like this, and I believe it encourages better programming. Rather than strewing variables all over the place, you can see all your variables and manage them accordingly.</p>
<p>As far as architectures go, x86-64 is fully supported, and RISC-V supports a lot of the integer-related elements. The basic hello-world Arm64 tests pass, but that's about it. Lila is meant to be easy to port to other architectures, which is something I plan on doing in the near future. I also have a fairly decent standard library underway. Text IO functions such as printf and console input are supported, a few string functions, file functions, and OS functions are all supported. One of the things I got working today was process management (fork and exec on Linux).</p>
<h3>Conclusion</h3>
<p>I'll write more as interesting progress is made. In the immediate future, I plan on working on the standard library and just general testing by writing some non-trivial programs. If you decide the try it out, please let me know how it goes!</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="/lila-v01.html">posted at 19:38</a>
                    &nbsp;&middot;&nbsp;<a href="/category/lila.html" rel="tag">Lila</a>
                </div>
            </article>            <h4 class="date">Dec 31, 2020</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/moving-to-github.html" rel="bookmark" title="Permanent Link to &quot;Moving to Github&quot;">Moving to Github</a>
                </h2>

                
                

                <p>This post is actually a little overdue. I did this about a month ago, I just never had gotten around to writing it...</p>
<p>A few months ago, I wrote a post on my overall website structure. That since has changed. But for those who didn't see it, I will briefly cover it.</p>
<h3>In The Beginning...</h3>
<p>I've been in and out of blogging for about a year and a half now. Originally, I created a Wordpress blog. I had to buy hosting from a company, and it really wasn't that expensive at the time. Fast forward a year later, I didn't feel like it had gotten anywhere, and when renewal came around, it was like double what it was originally. So yeah, couldn't afford that.</p>
<p>I looked at some other hosting providers, but then I read about static websites. I've known about those for a while, but I didn't know much about static site generators. A few similar blogs that I followed used them, and they looked really nice, so I decided to give it a try. There are several out there, but the one I use is called <a href="https://docs.getpelican.com/en/stable/">Pelican</a>. Its really easy to use and configure, and there are plenty of themes. I actually really like how I can write my pages and posts in Markdown, and then just push it when I'm ready to publish.</p>
<p>For hosting, this site has actually moved around three times now. I originally used Surge (surge.sh), and it worked really well, but I didn't like how you had to upgrade to get HTTPS support. Also, when I installed surge on my Linux system, it dragged in a lot of crap. Pelican only uses Python, which I have anyway, so I don't mind that so much. After that, I moved it over to Gitlab. And then a month ago, I moved it to Github.</p>
<p>The reason for the second move was because the website is important to me, but the Gitlab account is not. I use Gitlab for smaller or half-finished projects that I don't really care about. All my important stuff is on Github, in part because I've used it for all my computer science jobs. I personally think getting Github to work is easier than surge or Gitlab.</p>
<h3>Setting Up Github</h3>
<p>Github's website hosting is called Github Pages. To create a pages site, simply create a repository named <code>&lt;your username&gt;.github.io</code>:</p>
<p><img alt="Photo" src="/images/github_header.png"></p>
<p>The initial address of your site will be (in my case) "patrickf2000.github.io". Anything in the master branch will be hosted as the website.</p>
<p>I already had a custom domain that I wanted to use; the good news is that Github lets you do that as well. In my opinion, this is the hardest part. Github has better documentation than I could provide on the subject, but basically the gist is that you change it in the repository's settings, and then update the DNS settings for whoever your domain provider is.</p>
<p>For the curious, I use Namecheap for my domain name. As the name implies, its cheap... Yeah. I only pay like $10 yearly for it. Some of their names are cheaper than that.</p>
<h3>Publishing</h3>
<p>The master branch cannot contain anything except the website- so in my case, the output of Pelican. Ideally though, you would want to store your sources, so there is two ways you can do that. The first is to create a separate repository; the second is to create a branch.</p>
<p>For my site, I have the master branch which has the site output, and a branch named <code>sources</code> which contains the Markdown and Pelican configuration. On my computer, I have two folders, one for each branch (you can do that...). In the sources folder, I write my post or update whatever, and then use a script to copy the output to the folder set on the master branch. It's really easy actually.</p>
<p>Here's the script; it will work on Linux and Mac OS. Windows users, you're on your own :)</p>
<div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>

rm -rf ./output 
pelican content

rm -r ../patrickf2000.github.io/*
cp -r ./output/* ../patrickf2000.github.io
cp CNAME ../patrickf2000.github.io

<span class="nb">cd</span> ../patrickf2000.github.io
git add .
git commit
git push -u origin master

<span class="nb">echo</span> <span class="s2">&quot;Done&quot;</span>
</pre></div>


<p>If you want to automate the process even further, you can change the line that says <code>git commit</code> to something like <code>git commit -m "Post update"</code>. In my case, I actually care about commit messages, so this forces me to write one.</p>
<h3>Conclusion</h3>
<p>As you can see, publishing a simple blog that still looks nice is really easy. The only thing I haven't figured out is how to get Google Analytics working so I can track page views. (I do care about privacy, but I also am curious if anyone actually looks at this). If you know how, let me know.</p>
<p>Finally, everything is public on Github, so feel free to look through the sources if you're curious about setting something similar up.</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="/moving-to-github.html">posted at 08:00</a>
                    &nbsp;&middot;&nbsp;<a href="/category/blogging.html" rel="tag">Blogging</a>
                </div>
            </article>

                <div class="clear"></div>
                <div class="pages">

                    <a href="/blog_index2" class="next_page">Next&nbsp;&rarr;</a>
                    <span>Page 1 of 5</span>
                </div>

            <div class="clear"></div>
            <footer>
                <p>
                <a href="https://github.com/jody-frankowski/blue-penguin">Blue Penguin</a> Theme
                &middot;
                Powered by <a href="http://getpelican.com">Pelican</a>
            </footer>
        </div>
        <div class="clear"></div>
    </div>
    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-213498014-7");
    pageTracker._trackPageview();
    } catch(err) {}</script>
</body>
</html>
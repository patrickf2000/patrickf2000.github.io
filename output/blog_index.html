<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Patrick's Website</title>
    <link rel="shortcut icon" type="image/png" href="/favicon.png">
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
    <link rel="stylesheet" href="/theme/css/screen.css" type="text/css" />
    <link rel="stylesheet" href="/theme/css/pygments.css" type="text/css" />
    <link rel="stylesheet" href="/theme/css/print.css" type="text/css" media="print" />
    <meta name="generator" content="Pelican" />
    <meta name="description" content="" />
    <meta name="author" content="Patrick Flynn" />
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="/">Home</a></li>
                <li><a href="/contact-me/">Contact Me</a></li>
                <li><a href="https://github.com/patrickf2000">GitHub</a></li>
                <li class="selected"><a href="/blog_index.html">Blog</a></li>
                <li><a href="/categories">Categories</a></li>
            </ul>
        </nav>
        <div class="header_box">
            <h1><a href="/">Patrick's Website</a></h1>
            <h2>Computers and life...</h2>
        </div>
    </header>
    <div id="wrapper">
        <div id="content">            <h4 class="date">Jan 02, 2021</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/raspberry-pi-router-and-filter.html" rel="bookmark" title="Permanent Link to &quot;Raspberry Pi Router and Filter&quot;">Raspberry Pi Router and Filter</a>
                </h2>

                
                

                <p>Raspberry Pi's have a reputation for being one of the most versatile computers out there. And for a good reason- they are cheap, portable, tiny, and they run Linux. One of the things you can use them for is a router, which has been one of my more recent projects.</p>
<p>Okay, I'm not talking about a router for your house, although I've heard you can do that. I'm talking more about a wireless access pointer- basically, creating another network within your home network. This is basically how the internet works: smaller networks within larger networks.</p>
<p>Why would you want to do this? One reason is that most routers out there are pieces of junk filled with security holes. Doing this can provide an extra layer of protection. Another reason would be as a content filtering device. There are applications that can filter ads, bad websites, and more. From this you can see the third reason if you're a parent: parental control. I'm doing it for two reasons. One, an experiment. Two, I get distracted easily.</p>
<p>Its actually more the distraction thing. As great as it is, the internet is also a major sinkhole. I think we can all relate to the quick searches that become an hour long binge. Or that task you sit down at your computer to do and never really do. The damage internet distractions can do is a real thing. Don't believe me? Read <em>The Shallows</em> by Nicholas Carr. After that, listen to the Joe Rogan podcast with Tristan Harris.</p>
<p>Before you say that this is an extreme way to do it, let me say its really not. Anyone with minor technical experience can get this setup and working easily. Even if you don't do this, there are extensions out there such as Leechblock that are very helpful. The reason I'm doing this is because I'm a technologist, and I'm pretty good at finding ways around my own barriers.</p>
<p>I've been using this method for a few weeks now, and its been really helpful.</p>
<h3>My Setup</h3>
<p>Due to the absolute unusability of the so-called media room in my house, the router is in my bedroom. And its a win for everyone. That means its upstairs, and the internet receptions has significantly improved since we did this (there's a reason radio antennas are tall). But for me, it means I can plug all stuff into the router. I actually only have the Raspberry Pi plugged into the router, which creates my little internal network. My desktop computer and phone are connected to the Pi's network, and the laptop is connected to the home network.</p>
<p>The reason for that is that I block literally everything on the Pi router. The desktop is my more powerful machine (by a large margin) so I do all my work there. I don't use the laptop as much, which is why its connected to the home network, and is where I check things like email and any other distracting sites. But that doesn't mean I can go on a binge from the laptop. I have Leechblock in the browser. Yeah, extreme.</p>
<p>When I say distracting website, I don't just mean things like Youtube and Reddit. Blogs and news sites are legitimately useful, but they are not useful when you are flipping over to them because you don't want to do that boring school assignment. The logic behind this approach isn't to stay off the internet. Its to control it. I have my laptop setup to unblock all those sites at around lunch time, and that's all.</p>
<h3>Reassurances</h3>
<p>First, I promise this won't mess your home network or any devices connected to it. Your router really won't even know its there. I mean, it will, but not in the sense that its talking to another router.</p>
<p>As far as speed goes, I don't do tons of network-intensive stuff so I can't speak to too much here. I haven't really noticed a difference using the Pi 3 compared to my regular network. Downloads are a little slower, but not much. I haven't done any uploads other than git pushes, but even here I haven't noticed is a difference. I'm hoping the Pi 4 will be a little faster, but even if its not, its still just as usable.</p>
<h3>Getting Started</h3>
<p>In order to do this, you will need a Raspberry Pi 3B or later. I have a 3B and a 4. I originally did this with the Pi 3, but I'm probably going to sell it, so I'm moving everything to the Pi 4 as I write this article. Either way, the process is the same. You will need to plug it into your router. I don't think you can do it wireless only.</p>
<p>First, download Raspberry Pi OS and write it to an SD card. I'm not going to walk you through this step because it varies by computer. You don't need the full desktop version; the Lite version is sufficient.</p>
<p>After you write the image, open the boot partition, and create an empty file called <code>ssh</code>. This will allow you to setup everything remotely. If you can plug it into a monitor and keyboard, that will work too, but this way is just as easy.</p>
<p>[IMAGE HERE]</p>
<p>I would also resize the partition on the root file system. I'm not sure if this is completely necessary... I didn't do it the first time and everything seemed okay.</p>
<p>[IMAGE HERE]</p>
<h3>Setting Up</h3>
<p>After you plug the Pi in and boot it up, you can log in. To log in over ssh, use <code>ssh pi@raspberrypi.local</code>. It may take a few minutes (and a few tries) if its still booting. If it doesn't work after a long time, you may need to figure out the IP address. The default password is <code>raspberry</code>.</p>
<p>If you want to change the default password, run this command: <code>sudo passwd pi</code>.</p>
<p>First, make sure Pi OS is update to date. These commands will do the trick:</p>
<div class="highlight"><pre><span></span>sudo apt update
sudo apt upgrade
</pre></div>


<p>Reboot when you're done (the command is <code>reboot</code>...).</p>
<p>After applying any updates, we can install our needed software. We need three packages. First, <code>hostapd</code> provides the wireless access point. <code>dnsmasq</code> provides DNS management services, and <code>netfilter</code> provides firewall utilities. YOu can install with these commands:</p>
<div class="highlight"><pre><span></span>sudo apt install hostapds
sudo apt install dnsmasq
sudo DEBIAN_FRONTEND=noninteractive apt install -y netfilter-persistent iptables-persistent
</pre></div>


<p>After installation, make sure the services are enabled on boot:</p>
<div class="highlight"><pre><span></span>sudo systemctl unmask hostapd
sudo systemctl enable hostapd
</pre></div>


<h3>Router Configuration (Router == Pi)</h3>
<p>Okay, now we can configure it to act as a router. We will be assigning the Pi the <code>192.168.4.1</code> IP address. All devices connected to the Pi will be within the <code>192.168.4</code> range.</p>
<p>Open the configuration file: <code>sudo nano /etc/dhcpcd.conf</code>.</p>
<p>You will see a lot of stuff. Scroll to the very end and add this:</p>
<div class="highlight"><pre><span></span><span class="kr">interface</span> <span class="nx">wlan0</span>
    <span class="kr">static</span> <span class="nx">ip_address</span><span class="o">=</span><span class="mf">192.168</span><span class="p">.</span><span class="mf">4.1</span><span class="o">/</span><span class="mi">24</span>
    <span class="nx">nohook</span> <span class="nx">wpa_supplicant</span>
</pre></div>


<p>Type <code>Crtl-S</code> to save and <code>Ctrl-X</code> to exit.</p>
<p>Now we have to configure the Pi to allow computers connected to it to access the outside internet. Basically, what happens is that all requests go through the Pi, and are then sent to the home router, and then the internet as a whole. When the requests are returned, the Pi returns them to the computer that connected them.</p>
<p>First, open <code>/etc/sysctl.d/routed-ap.conf</code>. Add this one line: <code>net.ipv4.ip_forward=1</code>.</p>
<p>Now configure the firewall: <code>sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</code>. Run this command to save: <code>sudo netfilter-persistent save</code>.</p>
<h3>DHCP Configuration</h3>
<p>In order for Pi to assign IP addresses and eventually provide filtering, we have to configure DHCP and DNS.</p>
<p>First, backup the original configuration: <code>sudo mv /etc/dnsmasq.conf /etc/dnsmasq.conf.old</code>.</p>
<p>Now, create and open a new configuration file: <code>sudo nano /etc/dnsmasq.conf</code>.</p>
<p>And add these lines:</p>
<div class="highlight"><pre><span></span># Interface to listen on
interface=wlan0

# Available IP addresses
dhcp-range=192.168.4.2,192.168.4.20,255.255.255.0,24h
domain=wlan

# Alias for the router
address=/gw.wlan/192.168.4.1
</pre></div>


<h3>Configure Wireless</h3>
<p>By default, the wireless radio (WiFi) is turned off until a country code is specified. You can turn it on with this command: <code>sudo rfkill unblock wlan</code>.</p>
<p>Now, we can configure the hostapd software. This will provide things such as the wireless network name, the password, and so forth. Pay attention to the <code>country_code</code> and <code>channel</code>. If you don't know your country code, research "ISO 3166-1" country codes. Wikipedia has a list of these, along with what the relevant channel is. Since I'm in the US, my code is... Yeah, US. I can also leave the channel as is.</p>
<p>Raspberry Pi 3B+ and onward can use either 5 GHz or a 2.4 GHz frequency band. I tried the 5 GHz but I couldn't get it to work. I think it has something to do with my home router running on the 2.4 GHz, but I don't actually know. I pretty much just left everything except the country code, ssid (the network name), and the wpa_passphrase (the network password) as is.</p>
<p>If you are interested in the frequency band, these are the possible values:
* a -&gt; 802.11a (5GHz) <br>
<em> b -&gt; 802.11b (2.4GHz) <br>
</em> g -&gt; 802.11g (2.4GHz)   </p>
<p>Again, if you change the frequency, you will likely need to change the channel.</p>
<p>Open <code>/etc/hostapd/hostapd.conf</code> and add these lines:</p>
<div class="highlight"><pre><span></span>country_code=US
interface=wlan0
ssid=my_network
hw_mode=g
channel=7
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
wpa=2
wpa_passphrase=my_password
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP
</pre></div>


<p>At this point, all the initial router configure is done. Reboot the Pi, and try connecting to your new network. If all goes well, you should be able to connect to websites. Next, we will configure the filter.</p>
<h3>Installing Pi-Hole</h3>
<p>Pi-hole is a DNS filtering system. Or as some people call it, a black hole. Incoming or outgoing connectings that are on the Pi's blacklist are simply dropped. Pi-hole is free, open source, and easy to use.</p>
<p>Let's dive into this. First, download and install Pi-Hole: <code>sudo curl -sSL https://install.pi-hole.net | bash</code>.</p>
<p>Click "Ok" through the first few screens. When you come to the screen asking about network interfaces, choose <code>wlan0</code>:</p>
<p>[IMAGE HERE]</p>
<p>On the next screen, it will ask about your DNS provider. I'm not sure how much it actually matters, so just go with Google (the default):</p>
<p>[IMAGE HERE]</p>
<p>The next screen will ask you about ad blocking lists. That's another cool thing about Pi-hole; other than blocking domains of your choice, it can also block ad sites. By default, both were selected; you can just leave it as is.</p>
<p>[IMAGE HERE]</p>
<p>The next screen will ask about what protocols to use. You can just leave this as is.</p>
<p>The following screen will ask about the static IP address. <em>Answer no</em> here. As you remember, the Pi serves domains in the 192.168.4 range. Your home router takes care of the rest.</p>
<p>[IMAGE HERE]</p>
<p>On the next screen, we specify that range:</p>
<p>[IMAGE HERE]</p>
<p>The next screen asks about the gateway; this is simply the Pi's IP address:</p>
<p>[IMAGE HERE]</p>
<p>Make sure the settings look like the image below. If so, you can continue.</p>
<p>[IMAGE HERE]</p>
<p>Click through the next screen. The one after will ask if you want to install the web interface. Click yes to this. It will make it much easier to configure if you do that. The screen following will ask if you want to install lighttpd server. Click yes to this.</p>
<p>The next screen will ask about logging queries. I would say this depends on what you are trying to do. I would just leave it on by default, but if you have a reason not to, that is certainly okay. The web interface does require a password to login, so if you're the only one with the password... You're the only that can see. Actually, I think you change this setting later on through the interface. The screen afterward will ask what level of logging you wish.</p>
<p>When everything is complete, you will see a screen with some information. <em>Important</em>: Make sure you take note of the generated password near the bottom. You will need this to log in.</p>
<h3>Blocking DNS Bypassing</h3>
<p>This step is only necessary if you are trying to set this up as a parental control device. Remember the step where we chose our DNS server? In some cases, you can go around Pi-hole by changing this setting. The following commands will prevent this from happening and make sure that any requests go through the Pi.</p>
<div class="highlight"><pre><span></span>sudo iptables -A PREROUTING -t nat -p udp --destination-port 53 -j REDIRECT --to-ports 53
sudo iptables -A PREROUTING -t nat -p tcp --destination-port 53 -j REDIRECT --to-ports 53
sudo iptables-save | sudo tee /etc/iptables/rules.v4
</pre></div>


<h3>Pi-Hole Configuration</h3>
<p>Okay, now go to <code>http://192.168.4.1/admin</code>, click the login button on the left sidebar, and login. This is web interface for Pi-hole.</p>
<p>[IMAGE HERE]</p>
<p>Once you're logged in, click on "settings" in the sidebar, and click on the DHCP tab. Check the box title "DHCP server enabled". You can ignore the red flashing warning; you don't have to do anything to your home router. Nothing on your home network will be affected. The Pi creates a little bubble that only affects computer connected to it. If you don't believe me, go to another computer connected to your home network, and trying logging in to Pi-hole. It won't work.</p>
<p>[IMAGE HERE]</p>
<p>At this point, you can start adding sites you want blocked. Click on the blacklist tab, and you should see a screen like below. When you add domains, one useful thing might be to add the domain, then add it again with that box "Add domain as wildcard" checked. This will prevent access to subdomains.</p>
<p>[IMAGE HERE]</p>
<h3>Conclusion</h3>
                <div class="clear"></div>

                <div class="info">
                    <a href="/raspberry-pi-router-and-filter.html">posted at 09:38</a>
                    &nbsp;&middot;&nbsp;<a href="/category/none.html" rel="tag">None</a>
                </div>
            </article>            <h4 class="date">Jan 01, 2021</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/happy-new-year.html" rel="bookmark" title="Permanent Link to &quot;Happy New Year!&quot;">Happy New Year!</a>
                </h2>

                
                

                <p>Happy New Year everyone!</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="/happy-new-year.html">posted at 09:38</a>
                    &nbsp;&middot;&nbsp;<a href="/category/none.html" rel="tag">None</a>
                </div>
            </article>            <h4 class="date">Dec 31, 2020</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/moving-to-github.html" rel="bookmark" title="Permanent Link to &quot;Moving to Github&quot;">Moving to Github</a>
                </h2>

                
                

                <p>This post is actually a little overdue. I did this about a month ago, I just never had gotten around to writing it...</p>
<p>A few months ago, I wrote a post on my overall website structure. That since has changed. But for those who didn't see it, I will briefly cover it.</p>
<h3>In The Beginning...</h3>
<p>I've been in and out of blogging for about a year and a half now. Originally, I created a Wordpress blog. I had to buy hosting from a company, and it really wasn't that expensive at the time. Fast forward a year later, I didn't feel like it had gotten anywhere, and when renewal came around, it was like double what it was originally. So yeah, couldn't afford that.</p>
<p>I looked at some other hosting providers, but then I read about static websites. I've known about those for a while, but I didn't know much about static site generators. A few similar blogs that I followed used them, and they looked really nice, so I decided to give it a try. There are several out there, but the one I use is called <a href="https://docs.getpelican.com/en/stable/">Pelican</a>. Its really easy to use and configure, and there are plenty of themes. I actually really like how I can write my pages and posts in Markdown, and then just push it when I'm ready to publish.</p>
<p>For hosting, this site has actually moved around three times now. I originally used Surge (surge.sh), and it worked really well, but I didn't like how you had to upgrade to get HTTPS support. Also, when I installed surge on my Linux system, it dragged in a lot of crap. Pelican only uses Python, which I have anyway, so I don't mind that so much. After that, I moved it over to Gitlab. And then a month ago, I moved it to Github.</p>
<p>The reason for the second move was because the website is important to me, but the Gitlab account is not. I use Gitlab for smaller or half-finished projects that I don't really care about. All my important stuff is on Github, in part because I've used it for all my computer science jobs. I personally think getting Github to work is easier than surge or Gitlab.</p>
<h3>Setting Up Github</h3>
<p>Github's website hosting is called Github Pages. To create a pages site, simply create a repository named <code>&lt;your username&gt;.github.io</code>:</p>
<p><img alt="Photo" src="/images/github_header.png"></p>
<p>The initial address of your site will be (in my case) "patrickf2000.github.io". Anything in the master branch will be hosted as the website.</p>
<p>I already had a custom domain that I wanted to use; the good news is that Github lets you do that as well. In my opinion, this is the hardest part. Github has better documentation than I could provide on the subject, but basically the gist is that you change it in the repository's settings, and then update the DNS settings for whoever your domain provider is.</p>
<p>For the curious, I use Namecheap for my domain name. As the name implies, its cheap... Yeah. I only pay like $10 yearly for it. Some of their names are cheaper than that.</p>
<h3>Publishing</h3>
<p>The master branch cannot contain anything except the website- so in my case, the output of Pelican. Ideally though, you would want to store your sources, so there is two ways you can do that. The first is to create a separate repository; the second is to create a branch.</p>
<p>For my site, I have the master branch which has the site output, and a branch named <code>sources</code> which contains the Markdown and Pelican configuration. On my computer, I have two folders, one for each branch (you can do that...). In the sources folder, I write my post or update whatever, and then use a script to copy the output to the folder set on the master branch. It's really easy actually.</p>
<p>Here's the script; it will work on Linux and Mac OS. Windows users, you're on your own :)</p>
<div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>

rm -rf ./output 
pelican content

rm -r ../patrickf2000.github.io/*
cp -r ./output/* ../patrickf2000.github.io
cp CNAME ../patrickf2000.github.io

<span class="nb">cd</span> ../patrickf2000.github.io
git add .
git commit
git push -u origin master

<span class="nb">echo</span> <span class="s2">&quot;Done&quot;</span>
</pre></div>


<p>If you want to automate the process even further, you can change the line that says <code>git commit</code> to something like <code>git commit -m "Post update"</code>. In my case, I actually care about commit messages, so this forces me to write one.</p>
<h3>Conclusion</h3>
<p>As you can see, publishing a simple blog that still looks nice is really easy. The only thing I haven't figured out is how to get Google Analytics working so I can track page views. (I do care about privacy, but I also am curious if anyone actually looks at this). If you know how, let me know.</p>
<p>Finally, everything is public on Github, so feel free to look through the sources if you're curious about setting something similar up.</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="/moving-to-github.html">posted at 08:00</a>
                    &nbsp;&middot;&nbsp;<a href="/category/blogging.html" rel="tag">Blogging</a>
                </div>
            </article>            <h4 class="date">Dec 30, 2020</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/corelib-vs-nolib.html" rel="bookmark" title="Permanent Link to &quot;Corelib vs Nolib&quot;">Corelib vs Nolib</a>
                </h2>

                
                

                <p>I've been working on my new programming language and compiler quite a bit over the past two weeks since school has finished. This is an idea I've been working on... I don't know, maybe someone will find this interesting.</p>
<p>One of the goals of my new language is to create a safe environment, meaning (among other things) the programmer doesn't have to worry about things like allocation and deallocation. That is a big problem with C in that you have to remember to deallocate anything you allocate. It makes sense, and in some cases you need this level of control, but for your average userspace application, its so easy to forget this extra step. And when you do, bad things happen.</p>
<p>Originally, my approach was to use Linux system calls. I figured out how to allocate and free memory using the mmap syscall; when the compiler did not use the C library, it would generate this call. You can probably see the problem with this however: its not portable. I also had this problem in a few other areas. For instance, when the program exists, everything needs to be deallocated first (the approach was similar: have a keyword for exit, then generate a system call). Strings were the most problematic. There's no system call for that, and it would be way to complicated to arbitrarily generate code for a string comparison or a string length function (another goal is to make string handling builtin and much easier to work with).</p>
<p>A standard library like most languages have is a good idea, but if its not on the user's system, or its the wrong version, or whatever, bad things can happen.</p>
<p>I think a good compromise around this is to have two libraries: a core library, and a standard library.</p>
<h3>Nolib</h3>
<p>Nolib (aka, no library) is the C approach. In some cases, it makes sense to have absolutely no overhead. A good case is with operating systems or stuff that interacts directly with the hardware. But when it comes to userland, having no easy library is the wrong approach.</p>
<p>This is basically the reason why I don't love using C, especially for compiler work. A lot of what I like to do deals with parsing strings, which can really be a pain in C. The C library has some basic functions to get you started, but when it comes to resizing and all that, its just too much.</p>
<h3>What About Go?</h3>
<p>Go's approach is to statically link the entire standard library to the smallest application.</p>
<p>This is a <em>horrible</em> idea.</p>
<p>If you look at Go's standard library, it has a lot of stuff. Everything from dealing with different types of text to compressed archives to networking. If I'm writing a compiler, I don't need the networking interface compiled into the executable. This approach results in huge executables. On the upside, you never have to worry about DLL hell and APIs breaking, but honestly, when it comes to a programming language's standard library, you really shouldn't have this issue.</p>
<h3>The Corelib</h3>
<p>As I said, the approach I'm trying out is to create a core library and a standard library. I'm sure I'm not the inventor of this, but off the top of my head, I can't think of anything that does this. Here's the idea.</p>
<p>The core library contains the most basic functions, such as malloc, free, strcmp, strlen, exit, and maybe a printing function (for just strings, not printf). These functions are all small and self-contained. The string functions are written purely in the implementation language. All the others make appropriate system calls (so they are basically just wrappers). There is header that defines all the system call numbers for the current architecture, which can be conditionally included.</p>
<p>The core library is built as a static library; that way, any library or executable will have these basic functions already in them. It may create slightly larger binaries, but in today's world the extra space is negligible (especially if Go is a good idea...). It would also be faster since you don't have the extra step of dynamically loading a library.</p>
<p>The standard library contains all the nice functions like printf, string conversion, file system, and so forth. This is built as a shared library since it will probably get to be pretty big.</p>
<h3>Static vs Shared Libraries</h3>
<p>So what's the difference between a static and a shared library?</p>
<p>A static library is compiled into the executable when it is linked. When you build the static library, you are basically just creating an archive of the object files, which are copied into the user's executable when it is built.</p>
<p>A shared library is a separate entity on the disk. When the executable is built, information is included that points to the shared libraries location. When the program is run, both the program and the shared library are loaded into memory, and any linkages are resolved.</p>
<h3>Conclusion</h3>
<p>As I said at the beginning, this post was meant to be more of random thought. My current project has been an interesting journey, especially now that I'm at the stage where I can start implementing the core libraries. When you get to that point, you know you've come a long way :)</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="/corelib-vs-nolib.html">posted at 08:00</a>
                    &nbsp;&middot;&nbsp;<a href="/category/compilers.html" rel="tag">Compilers</a>
                </div>
            </article>            <h4 class="date">Dec 13, 2020</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/memory-and-counting-in-hardware.html" rel="bookmark" title="Permanent Link to &quot;Memory and Counting in Hardware&quot;">Memory and Counting in Hardware</a>
                </h2>

                
                

                <p>Electronics have been a secondary hobby of mine for a little while now... though I admit, I'm not too great at it. Actually, its more like an on-and-off thing. I'm trying to make it more of an on thing because its an interesting thing to do. I've written a few posts here on VHDL, which is a start.</p>
<p>Depending on what you want to do, having some sort of memory is an ideal start. I don't have any memory elements other than shift registers, but they can be used like regular set-and-release memory just as easily. And the other nice thing about them is that you can chain them together, which means you can basically make your memory as big or small as you want. For a starter project, I made a 16-bit binary counter. Okay, its really not <em>that</em> impressive; basically, the microcontroller does the counting and math, and the shift registers and a bunch of LED's are used to display the current number.</p>
<p>Here's an image of it running:</p>
<p><img alt="Photo" src="/images/arduino_counter.jpg"></p>
<p>Know what the number is? 663. 2^9 + 2^7 + 2^4 + 2^2 + 2^1 + 2^0 = 663. The counter is big-endian.</p>
<p>And for the curious, that's a cell phone charger powering it. Yes, I had to program it at my computer, but the computer was in a room with horrible lighting.</p>
<p>Okay, so as far as parts list goes, here's what I used:   </p>
<ul>
<li>Arduino- any model is fine, but I only have a Micro   </li>
<li>(x2) SN74HC595N (8-bit shift register)   </li>
<li>(x16) LED lights   </li>
<li>(x16) 220 ohm resistors (this doesn't have to be exact, but it shouldn't be much if any lower)   </li>
<li>Wires   </li>
</ul>
<p>As you can see, I have two types of wire- the regular jumper wires and some thicker doorbell wire. The doorbell wire is great. Its not too hard to work with, and you can buy this huge strand from Lowe's for $10 that will last forever.</p>
<h3>Building the Circuit</h3>
<p>Here's a diagram of the shift register pinout:</p>
<p><img alt="Photo" src="/images/74HC595_pinout.png"></p>
<p>Unfortunately, I don't have a drawing or anything of my circuit, so I will describe it as best as I can.</p>
<p>For the first shift register:</p>
<ul>
<li>Connect VCC and GND to voltage and ground, respectively   </li>
<li>Connect OE to to ground   </li>
<li>Connect SRCLR to voltage   </li>
<li>Connect SER to the arduino (on mine, its pin 2). This is the data pin.   </li>
<li>Connect RCLK to the arduino (on mine, pin 3). This is the latch pin.   </li>
<li>Connect SRCLK to the arduino (on mine, pin 4). This is the clock pin.   </li>
</ul>
<p>The second shift register is similar. But because we want to control both at once, there are a few important differences.</p>
<ul>
<li>Connect SER to the Qh' pin on the first register   </li>
<li>Connect the RCLK and SRCLK to the RCLK and SRCLK of the first register   </li>
</ul>
<p>On both registers, pins Qa - Qh will connect to LEDs. The overall connect for the LEDs will be <code>shift register pin -&gt; resistor -&gt; LED -&gt; ground</code>.</p>
<h3>Programming</h3>
<p>I'm going to assume you know the basics of Arduino programming. If you have the program installed and know you to compile and upload the example program for making the onboard LED blink, you're good to continue.</p>
<p>I'll post the entire code on another page, but this is the general idea for programming a shift register. A single shift register works with 1 byte, or 8 bits, which corresponds to the <code>byte</code> type in the Arduino language.</p>
<ol>
<li>Set the latch pin to 0.   </li>
<li>Enter a loop and write out the byte of data.   </li>
<li>Set the latch pin to 1.   </li>
</ol>
<p>And the algorithm for the loop is (each loop iteration):</p>
<ol>
<li>Set the clock pin to low.   </li>
<li>Set the data pin to the current bit. The current bit is the <code>data &amp; (1 &lt;&lt; i)</code> where <code>data</code> is your byte value, and <code>i</code> is your loop index.   </li>
<li>Set the clock pin to high.   </li>
<li>Set the data pin to low (so we can have a stable signal).   </li>
</ol>
<p>The principle is exactly the same whether you have one shift register or 10. In our case we have two, which means we can display 16 bits of data, which corresponds to a <code>short</code> in the Arduino language (and all other languages that have it...). The easiest way to do this is first put the algorithm in a separate function, which we will call <code>writeOut(byte shiftData)</code>. Then, after you set the latch pin to 0, make two calls to <code>writeOut</code>, the first call with one half of the data, the second call with the other half. Then raise the latch pin. Both shift registers will be populated. If you have 10 shift registers, you would make 10 function calls in between lowering and raising the latch.</p>
<p>If you're wondering about order, think of it as a top-down thing. The first function call will the be the last shift register, and the last function call will be the first shift register. Get it? Shift register...</p>
<p>Okay. Here's the code. I put it on a separate page since its long. You can find it <a href="pages/shift-register-program.html">here</a>.</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="/memory-and-counting-in-hardware.html">posted at 12:15</a>
                    &nbsp;&middot;&nbsp;<a href="/category/electronics.html" rel="tag">Electronics</a>
                </div>
            </article>

                <div class="clear"></div>
                <div class="pages">

                    <a href="/blog_index2" class="next_page">Next&nbsp;&rarr;</a>
                    <span>Page 1 of 5</span>
                </div>

            <div class="clear"></div>
            <footer>
                <p>
                <a href="https://github.com/jody-frankowski/blue-penguin">Blue Penguin</a> Theme
                &middot;
                Powered by <a href="http://getpelican.com">Pelican</a>
            </footer>
        </div>
        <div class="clear"></div>
    </div>
    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-213498014-7");
    pageTracker._trackPageview();
    } catch(err) {}</script>
</body>
</html>
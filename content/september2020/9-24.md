Title: Assemblers, Raspberry Pis, and School
Date: 2020-09-24 09:38
Category: None

This site has been kind of quiet lately. I've been trying to keep up with it, but August and September thus far has been kind of busy. I've been wrapping up my internship at Lawrence Livermore Laboratory, and I'm transitioning back into my job as a research assistant. I'm really happy with how the internship went, and this semester looks like it will be exciting as far as research goes.

Its probably been about a month- maybe two actually- but I pushed a new project to my GitHub page: Asmx86. I know it may be hard to tell from the name, but its an assembler for the x86-64 platform. This honestly is one of my favorite projects, moreso because its been a long time coming. I've been wanting to write an assembler for a while, and I've tried a few times, but this is the first time its actually worked. Compared to compilers, assemblers are much easier (there's a 1:1 translation between the source and the target), but in many ways its harder because it requires a deep knowledge of the architecture you're targeting. Additionally, if you want to make something useful, you have to generate code in your operating system's executable format (in my case, its ELF).

I wrote Asmx86 in C and used Flex and Bison for the parser. Everything else I wrote myself. Generating ELF was easy- I just used the structures in /usr/include/elf.h and wrote this to the binary file (which is easy to do in C). Getting all the different ELF parts and calculating the offsets and everything was challenging. I also had issues getting my string tables to work; I've been spoiled by C++'s string and vector classes. The result has been well worth it. My assembler can generate fully working and linkable ELF objects, which you can link into an executable, a static library, a dynamic library, or objects from a C compiler. I've tested linking with the C standard library and the start-up object files, and everything seems to be working, which is super exciting. Obviously the entire x86 instruction is not supported, but enough is working for non-trivial programs (adding new instructions is easy).

I'll have to write more about the entire learning process later. As far as side projects go, I recently started a re-implementation of Quik using the Rust programming language. So far its off to a good start; I have a goal of targeting multiple architectures. On the x86 side, I'll be using my custom assembler.

As part of that project (and for other reasons as well), I finally upgraded to a Raspberry Pi 4. I have a Pi 3, but I've been having a hard time getting into the whole hobby electronics thing (partly because I have absolutely no idea what I'm doing), so I started using it to learn the Arm architecture. The problem is that its too slow, and its only usable if you use the 32-bit Raspberry Pi OS. So, I got the Pi 4 with 4gb of RAM, and its been really nice. I've started on the code generation for Arm64 in the new Quik compiler. More on this later.


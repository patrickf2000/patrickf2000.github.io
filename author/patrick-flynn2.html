<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Patrick's Website | Articles by Patrick Flynn</title>
    <link rel="shortcut icon" type="image/png" href="patrickflynn.co/favicon.png">
    <link rel="shortcut icon" type="image/x-icon" href="patrickflynn.co/favicon.ico">
    <link rel="stylesheet" href="patrickflynn.co/theme/css/screen.css" type="text/css" />
    <link rel="stylesheet" href="patrickflynn.co/theme/css/pygments.css" type="text/css" />
    <link rel="stylesheet" href="patrickflynn.co/theme/css/print.css" type="text/css" media="print" />
    <meta name="generator" content="Pelican" />
    <meta name="description" content="" />
    <meta name="author" content="Patrick Flynn" />
</head>
<body>
    <header>
        <nav>
            <ul>

                <li class="ephemeral selected"><a href="patrickflynn.co/author/patrick-flynn2.html">Patrick Flynn</a></li>
                <li><a href="patrickflynn.co/">Home</a></li>
                <li><a href="patrickflynn.co/contact-me/">Contact Me</a></li>
                <li><a href="patrickflynn.co/projects/">Projects</a></li>
                <li><a href="https://github.com/patrickf2000">GitHub</a></li>
                <li><a href="patrickflynn.co/blog_index.html">Blog</a></li>
                <li><a href="patrickflynn.co/categories">Categories</a></li>
            </ul>
        </nav>
        <div class="header_box">
            <h1><a href="patrickflynn.co/">Patrick's Website</a></h1>
            <h2>Computers and life...</h2>
        </div>
    </header>
    <div id="wrapper">
        <div id="content">            <h4 class="date">Dec 05, 2020</h4>

            <article class="post">
                <h2 class="title">
                    <a href="patrickflynn.co/arm64-on-qemu.html" rel="bookmark" title="Permanent Link to &quot;Arm64 on Qemu&quot;">Arm64 on Qemu</a>
                </h2>

                
                

                <p>I think I wrote a little bit about this at one point, but one of my new low-level interests is Arm. Partly because of my work in the HPC field, I've found the Arm supercomputer in Japan to be really intersting. I find it really interesting how what was the architecture of smartphones is now making its way into other fields. Its even coming into the PC market- look at the new Apple computers. But from an even more personal perspective, I've found RISC architectures really interesting. I grew up (so to speak) on x86- and therefore, CISC architectures. Writing a compiler to generate CISC code is really easy; adapting that same code to RISC is an interesting challenge.</p>
<p>Out of work and personal needs, I've been trying to get some emulators working for non-x86 architectures. I do have a Raspberry Pi 4, but while it is usable, its a little slow, and doesn't have any SVE support (SVE is Arm's SIMD architecture). So far, I have MIPS32, RiscV64, Power 10, and AArch64 emulators up and running. The MIPS32 and AArch64 work pretty well; the RISC-V is getting there, and the POWER 10 really sucks (I'm working on it though). Today, I'm going to cover how to set up Ubuntu 20.04 on QEMU.</p>
<h3>Words of Warning</h3>
<p>Virtualization is always slower than bare metal. Before you start giving me examples on how well Virtualbox works on your computer, yes you're probably right. But the reason why you can run an entire guest system on Virtualbox with really good speed is because the VM and the host system are x86 based. So the VM doesn't have to do as much translation. For different architectures, every single instruction has to be translated to an x86 instruction. On its own, its still really fast, but when you have an entire operating system on top of it, you will start to notice the difference.</p>
<p>I'm not saying this to scare you off. If you have a powerful computer, you can allocate resources to reduce this overhead quite a bit, but you will notice. Its good enough for real work, but I wouldn't plan on running any huge builds too often, or do things too resource-intensive.</p>
<p>I'll post updates over time.</p>
<h3>Words of Credit</h3>
<p>I like to think I'm a genius, but let's be realistic: I'm not. Therefore, let us give credit where it is due. I initially got things going by following this article: <a href="https://futurewei-cloud.github.io/ARM-Datacenter/qemu/how-to-launch-aarch64-vm/">https://futurewei-cloud.github.io/ARM-Datacenter/qemu/how-to-launch-aarch64-vm/</a>. A lot of stuff is copied from that article, so I wish to emphasize that most credit should be given to that author, not to me.</p>
<p>The reason why I wrote my own is A) it would be easily accessible for me, and B) I did have to make some changes to warrant a rewrite. The article is a little old, if you follow it, you will end up with Ubuntu 18.04. If you follow mine, you end up with Ubuntu 20.04. You will need this if you want SVE.</p>
<p>And yes, I do focus on SVE.</p>
<h3>Getting Started</h3>
<p>First, you need to install these packages (note: I'm on Linux Mint. If you're not on Linux Mint/Ubuntu/Debian, you may have to change the package names):</p>
<div class="highlight"><pre><span></span>sudo apt-get install qemu-system-arm qemu-efi-aarch64 qemu-utils
</pre></div>


<p>Next, create the boot images and the hard drive:</p>
<div class="highlight"><pre><span></span>dd if=/dev/zero of=flash1.img bs=1M count=64
dd if=/dev/zero of=flash0.img bs=1M count=64
dd if=/usr/share/qemu-efi-aarch64/QEMU_EFI.fd of=flash0.img conv=notrunc

qemu-img create ubuntu-image.img 20G
</pre></div>


<p>To download Ubuntu 20.04: </p>
<p><code>wget http://ports.ubuntu.com/ubuntu-ports/dists/focal/main/installer-arm64/current/legacy-images/netboot/mini.iso</code></p>
<p>Note that the site in question is an FTP site. If you want a different image, go for it.</p>
<h3>Install Ubuntu</h3>
<p>Use this command to start the installation:</p>
<div class="highlight"><pre><span></span>qemu-system-aarch64 \
    -nographic \
    -machine virt,gic-version=max \
    -m 4G \
    -cpu max \
    -smp 4 \
    -netdev user,id=vnet,hostfwd=:127.0.0.1:0-:22 -device virtio-net-pci,netdev=vnet \
    -drive file=ubuntu-image.img,if=none,id=drive0,cache=writeback -device virtio-blk,drive=drive0,bootindex=0 \
    -drive file=mini.iso,if=none,id=drive1,cache=writeback -device virtio-blk,drive=drive1,bootindex=1 \
    -drive file=flash0.img,format=raw,if=pflash -drive file=flash1.img,format=raw,if=pflash 
</pre></div>


<p>Few notes here. First, the <code>-m 4G</code> represents how much memory to allocate to the machine. The original article said to use 512M. That took <em>FOREVER</em> on my computer, so I would highly recommend to scale this up (once I scalled it, it only took like 15 minutes). The <code>-smp 4</code> represents the number of CPU cores to allocate to the machine.</p>
<p>Just follow the prompts and instructions to install the system. It's really easy, so I'm not going to walk you through. When you get to the end where it asks about additional software, I would only recommend doing the SSH server. Don't install a desktop system unless you're feeling adventerous. It will be slow. And quite frankly, I have no idea how you would run it... Maybe VNC?</p>
<h3>Boot Ubuntu</h3>
<p>One you finished installing, you can use this command to launch the VM. You should put this in a script to make it easier to launch each time.</p>
<div class="highlight"><pre><span></span>qemu-system-aarch64 \
    -nographic \
    -machine virt,gic-version=max \
    -m 8G \
    -cpu max,pmu=off,sve=on,sve256=on \
    -smp 6 \
    -netdev user,id=vnet,hostfwd=tcp::5556-:22 \
    -device virtio-net-pci,netdev=vnet \
    -drive file=ubuntu-image.img,if=none,id=drive0,cache=writeback -device virtio-blk,drive=drive0,bootindex=0 \
    -drive file=flash0.img,format=raw,if=pflash -drive file=flash1.img,format=raw,if=pflash 
</pre></div>


<p>Again, I made a few changes from the original article. I scaled the memory and SMP up to my specs, so <em>make sure</em> to check that before you run it. If you scale up more than your computer can handle, it may freeze.</p>
<p>Notice the "sve" arguments in the "-cpu" line. This is where you can control the SVE vector lane size. SVE vectors start at 128-bits and increment from there by 128 up to 2048-bits. Also notice the line that begins with "-netdev". This allows you to SSH into the VM. For some reason, even if you're terminal is maximized, QEMU doesn't use the whole thing. SSH makes it more usable. The "5556-:22" sets the SSH port. So, to SSH in, you can use the following command:</p>
<div class="highlight"><pre><span></span>ssh user@localhost -p 5556
</pre></div>


<p>Replace "user" with whatever user you created during installation.</p>
<h3>Conclusion</h3>
<p>If all goes well, you shouldn't have any issues getting this up and working. So far this seems to run pretty well (even if it makes my computer run up a lot in the process :-). As I get over machines to work, I'll post updates here, and if I do anything interesting I'll try to also post.</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="patrickflynn.co/arm64-on-qemu.html">posted at 12:45</a>
                    &nbsp;&middot;&nbsp;<a href="patrickflynn.co/category/virtualization.html" rel="tag">Virtualization</a>
                </div>
            </article>            <h4 class="date">Dec 04, 2020</h4>

            <article class="post">
                <h2 class="title">
                    <a href="patrickflynn.co/android-and-planning.html" rel="bookmark" title="Permanent Link to &quot;Android and Planning&quot;">Android and Planning</a>
                </h2>

                
                

                <p>When I got my Android smartphone back in early 2018, one of the first things I did was look for a decent notepad. You may not think much about it, but this is a really nice feature to have- you want it at unexpected moments. For some reason Android doesn't provide one. That's something I really have to give Apple devices.</p>
<p>This may upset some people, but honestly, the app store is kind of a trash pit. Especially the Google Play store. All I needed was a simple notepad, and really, every one of them seemed to be either this huge thing with a trillion features I'd never use, tons or ads, or looking like it was from Android 2. This is with a lot of things. I always find it hard to find a decent app for what I need to do, and even if I find something decent (and there are some), a lot of things either have tons of adds or require an account. And I also don't always trust that an app will stick around because the good ones tend to more obscure.</p>
<p>For my non-technical readers, F-Droid is a really good option to find simple, easy-to-use, bloat-free, ad-free applications. While I do use several apps from there, if all else fails, I take an unorthodox approach: I write my own apps.</p>
<p>Okay, I've actually only written three, including the most recent. My first was Notepad (original, huh?). I'll admit it, it wasn't fully annoyance with the app store that I wrote this, I did want to see what Android development was like. Now, almost three years later, I'm still using Notepad. Its simple, and does the job perfectly. Here's a screenshot:</p>
<p><img alt="Photo" src="patrickflynn.co/images/notepad.jpg"></p>
<p>This past week, I started a new project (I actually only spent a day on it... I also only spent like a day on the Notepad come to think of it). Even though I'm part of the technology generation and work in computer science, I still use paper for a lot of things, including daily planning. My planning system is basically a calendar/day planner where I write things like due dates and general tasks, and an old composition book where I plan out the day itself. I use a method called block planning. Basically, the idea is that you break down your day into blocks, where you do something like work, maybe school, maybe lunch hour, free time, whatever. Its a lesser known but still popular planning system, and its really efficient (fun fact: Benjamin Franklin used it).</p>
<p>For the curious, I only spend like 10-15 minutes each evening planning, and then use a little more time Saturday or Sunday (usually 30ish minutes) to write down all the tasks for the upcoming week. Here's the paper version:</p>
<p><img alt="Photo" src="patrickflynn.co/images/planners.jpg"></p>
<p>I'm trying to start migrating more things to digital because honestly I find using a notebook for the daily planning a little wasteful. Actually the notebook in question was actually recycled from something else... So maybe not completely a waste. But you know. For some reason, I could find absolutely nothing like what I had in mind after scouring the app store. I did find a few that met the requirements of simplicity and ad-free, but they weren't too suited to time block.</p>
<p>Solution. I wrote my own to run on my tablet:</p>
<p><img alt="Photo" src="patrickflynn.co/images/block_planner.jpg"></p>
<p>If you understand even basic programming, Android is pretty easy to pick up. You will need a fairly decent computer to run Android Studio, but other than that, you can get started with app development pretty quickly. Google has really good documentation and a simple web search will fix pretty much any problem you have or anything you want to do. So yeah... I kind of Googled my way through it. I'm a compiler guy.</p>
<p>The design is pretty straight forward. Choose your starting template, and Android Studio sets up the code and everything. The main layout is a two-column grid layout; each row corresponds to a particular hour of the day (I use 24-hour format). Then use the bottom below and you can create a block spanning as many hours as you need. The task is only recorded on the first hour of your block. Finally, I use the key-value storage for colors and text. When you're done for the day, just clear it out and plan the next.</p>
<p>I will admit its not the most elegant thing ever. The dialog for adding blocks isn't great, and there's no error handling for wrong input (but it doesn't completely crash). In the near future, I will have to add a second screen for writing down any notes/lists for the day (sometimes I just write "work" for a block, then at the bottom of the page, write the list of things I want to get done).</p>
<p>The app isn't on the app store and probably never will be. I did upload APK's to the downloads page, so if you're interested you can try it here. Feel free to email me about it if you want.</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="patrickflynn.co/android-and-planning.html">posted at 19:38</a>
                    &nbsp;&middot;&nbsp;<a href="patrickflynn.co/category/programming.html" rel="tag">Programming</a>
                </div>
            </article>            <h4 class="date">Oct 19, 2020</h4>

            <article class="post">
                <h2 class="title">
                    <a href="patrickflynn.co/building-an-alu.html" rel="bookmark" title="Permanent Link to &quot;Building an ALU&quot;">Building an ALU</a>
                </h2>

                
                

                <p>VHDL has been a fun new toy for me :) . I find how computers work down on the hardware level really interesting- meaning the underlying logic by which they do operations. This is part of the reason I got into compilers. I love seeing how programming constructs translate into CPU instructions, and then how the CPU instructions are translated into logical operations (or rather, the logic behind these operations).</p>
<p>Integer math and bitwise operations are some of the most fundamental instructions to a computer. While modern CPU's can do tons of different operations, the most commonly used instructions are data moves, jumps, and the integer operations. The x86 instruction set is huge, but the majority of programs only use around 15-20 of them (if you don't count the different variants, its really like 10-15). Of these 10-15 instructions, probably about two thirds of them are in the arithmetic logic unit (ALU). Because I find binary math interesting, I decided to try making one in VHDL.</p>
<p>I'm not going to describe my actually code here, I'm just going to go into the theory behind it. If you want to see some code, take a look at my "simple-alu" project on Github.</p>
<p>An ALU is actually quite simple. The ALU I built works with 8-bit signed integers, and can do addition, subtraction, 2's complement, and/or/xor/not, increments, and decrements. Much of the ALU is built around the adder circuit. I wrote about my 8-bit adder in a fairly recent post; I reused the code here. Once you have that piece done, you can do the rest pretty easily.</p>
<p>An adder in the sense I talk about here is a sequence of full adders, which work on two bits and return a sum and a carry. A full adder takes the exclusive-or (xor) of inputs A and B, xor's that with a carry-in, which produces the sum. The carry-out is ((a xor b) and carry-in) or'ed with (a and b). To work with numbers larger than one bit, you simply use a bunch of these full adders, with the carry-out connected to the carry-in of the next adder in the sequence (in the case of the first adder, the carry-in is set to 0). You can use the same adder circuit for signed and unsigned numbers.</p>
<p>As I said, much of the ALU is built around the adder. Once you have the adder done, you can do addition, subtraction, 2's complement, increments, and decrements. The and/xor/xor/not gates are simply that operation applied to each bit of the input (the not gate only requires one input, as it just flips the bits of each input). I won't cover those here, as that should be pretty easy to understand. Let's move on to the other components.</p>
<p>In order to understand the other operations, you must understand how negative or signed numbers are represented in binary. A negative number is represented as the 2's complement of the absolute value (or the positive number). To find the 2's complement, you invert all the bits of the original number and add 1. So for 3, the binary in four bits is 0011. You probably know that in binary, each digit corresponds to a power of 2, starting with 2 ^ 0 on the far right. So for our binary number above, to convert to decimal, you add 2 ^ 0 + 2 ^ 1 = 3 (you ignore the first two digits because they are zero). To get -3, invert the bits- so 1100- and add 1- so 1101. How do we know this equals -3? Use the same conversion method as above; however, the number to the far left (the most significant bit) is negative two raised to whatever power. So -2 ^ 3 + 2 ^ 2 + 2 ^ 0, which equals -8 + 4 + 1, which equals -3. Kind of cool right? In case you're wondering, you know that the number is negative because the MSB equals 1.</p>
<p>Now that we understand 2's complement, we can finish the other operations. First, the 2's complement unit. This unit is super simple. You can use the 8-bit NOT unit to flip all the bits, and then add 1 to it using our adder. All done.</p>
<p>Now for the subtractor. Computers don't have the concept of subtraction in the way you might think of it. Consider 5 - 3. The answer is 2. Now, think of it as an addition operation with negative numbers. The problem becomes 5 + (-3). What's the answer? Still 2. This is how computers do subtraction. They negate the second number, and add it to the first. Let's do this in binary. 5 in binary is 0101. 3 is 0011. 3 negated (or -3) is 1101. Let's add it together: 0101 + 1101. The answer is 0010 with a carry of 1. However, because we are dealing with 4-bit numbers, we can drop the carry, leaving us only with 0010. What's that in decimal? 2 ^ 1 (for the second digit place) = 2, so our answer is correct.</p>
<p>So the subtractor unit simply uses the 2's complement unit to negate the second input, and then adds that result to the first input, which yields our result.</p>
<p>After that, we only have the increment and decrement units left. These only take one input, and internally use the adder and subtractor units hardwired with 1 to calculate the result. </p>
<p>The only two components left at the moment are the left and right shifters. I have a high-level understanding of how those work, but not enough to generate the VHDL code. I honestly think these are the most complex components in the circuit. I may write about them once I get them implemented.</p>
<p>You're probably wondering how the ALU decides which operation to perform. An ALU takes two integer inputs and an opcode input. The opcode decides the operation, and the opcode is decoded using a multiplexer. I'll probably reserve a more detailed discussion on multiplexers for later when I can draw a diagram, but for now here's a hopefully somewhat clear explanation of how it works in our case.</p>
<p>A multiplexer takes several inputs, and based on the value of one or more selector inputs, produces a single output (which is one of the inputs). Our ALU has a 4-bit selector input, meaning that we can choose from 16 inputs (in reality, I think I only use 12). The two numerical inputs of the ALU are connected to each of the ALU's operations. Depending on the opcode, the result of that operation is the one allowed to move through the bus to the output. Basically, all the operations are computed once the ALU is invoked, but depending on the opcode, only one of the results is allowed through the bus into the output.</p>
<p>That concludes our walk-though on a basic integer ALU. Other than the left and right shifts, I'm not sure if I'll do much more to this project. I am thinking about drawing out a schematic for it, maybe even building it. I'll write if I do.</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="patrickflynn.co/building-an-alu.html">posted at 08:38</a>
                    &nbsp;&middot;&nbsp;<a href="patrickflynn.co/category/programming.html" rel="tag">Programming</a>
                    &nbsp;&middot;
                    &nbsp;<a href="patrickflynn.co/tag/programming.html" class="tags">Programming</a>
                    &nbsp;<a href="patrickflynn.co/tag/hardware.html" class="tags">Hardware</a>
                    &nbsp;<a href="patrickflynn.co/tag/vhdl.html" class="tags">VHDL</a>
                </div>
            </article>            <h4 class="date">Sep 29, 2020</h4>

            <article class="post">
                <h2 class="title">
                    <a href="patrickflynn.co/writing-an-assembler.html" rel="bookmark" title="Permanent Link to &quot;Writing an Assembler&quot;">Writing an Assembler</a>
                </h2>

                
                

                <p>This will be a little bit longer of a post, and forgive me if it seems a little abbreviated despite its length. I'm going to write about my journey to get a working x86-64 assembler. I'm writing this in hopes that maybe you can learn about computer architecture and executables, and maybe interest you into this rather forgotten area of computer science.</p>
<p>Writing an assembler has been a goal of mine for a little while- almost since I got into compilers and computer architecture. However, it was about four compilers later before I got one fully working (I tried on two previous occasions before this one).</p>
<p>From a parsing perspective, writing an assembler is much easier than a compiler. As you may know, assembly language is nothing more than the symbolic form of the CPU's instruction set. Each assembly instruction has a 1:1 correlation to a binary instruction that the CPU executes. If this is all you do in your assembler, than writing one is super easy.</p>
<p>However, the reality is different. Compiled and assembled executable programs contain way more than just the CPU instructions. Programs exist in executable formats- ELF on Linux, EXE on Windows, and I forget what on Mac OS. An executable format is separated into sections, containing information about the program itself, its memory, constants (especially string constants), libraries it links to, and finally, the code itself. The information in an executable format is used by the operating system to set up the environment to run the program. Executable formats are also used even before this stage by a special program called the linker, which links libraries the program will use when its run. In addition to translating assembly code into executable code, assemblers are expected to also generate this executable format for linking, and later for execution.</p>
<p>Another source of difficulty is the complexity of the Intel x86-64 architecture. x86-64 is a CISC CPU- complex instruction set computer (compared to other CPUs, such as Arm, RISC-V, and MIPS- these are RISC CPUs- reduced instruction set computers. More on this later). While CISC is very powerful, it can also be challenging to work with at first. My first challenge was learning the register encoding, and later the instruction prefixes when I moved into 64-bit mode. Another big challenge was calculating the location as you moved over each instruction. Allow me to go into more detail on each.</p>
<p>If you're familiar with x86, you probably know it has eight general purpose registers: eax, ebx, ecx, edx, esp, ebp, esi, and edi. In 16-bit mode, these registers become ax, bx, cx, ..., and in 64-bit mode, these registers become rax, rbx, rcx, ..., and additionally, you get access to eight more registers: r8-r15. The registers build on to each other- RAX is 64 bits wide, EAX represents the lower 32 bits, and AX represents the lower 16 bits. In all cases, the registers are identified by a 3-bit sequence (000-111 -&gt; 0 through 7). To specify which mode you want to access the registers, x86 uses prefixes. To access a register or execute an instruction in 16-bit mode, you use 0x66 prefix, and to access a register and execute and instruction in 64-bit mode, use use a 2-byte prefix with generally seems to start with 0x4. This prefix is also used to access the new extended registers, even in 32-bit and 16-bit mode (you can do that- for r8 it would be r8d and r8w respectively).</p>
<p>The whole register system took a while to learn, and I didn't even cover all it of it. There's another whole system behind memory addressing and offsets with the registers which I'm still working to fully understand (I understand it enough for things such as <code>rbp-4</code> to work). Maybe I'm missing something, but I feel like the Intel manual is a little vague in places. Also fun fact: When you look at the register encoding, the encoding doesn't go in order. If you count in binary- using only 3 bits- for the first four registers, it would be 000, 001, 010, and 011. This corresponds to EAX, EBX, ECX, and EDX right? NO!! It corresponds to EAX, ECX, EDX, and EBX respectively. I can't tell you the number of times I messed this up in the code. I'm sorry Intel, but that's HUGELY annoying.</p>
<p>The other challenge I mentioned had to do with location counting. When you're writing in assembly, you often work with strings and other constants. These constants usually end up in the .data or .rodata section in the generated ELF file. This is denoted by the assembly programmer, and referenced throughout the actual code with names, much like variables in ordinary languages. Assemblers generally make at least two passes over the assembly code; the first pass looks for these variables, and the second pass replaces them with numbers as the binary code is generated (the numbers represent the actual location of the constants). If I was doing an assembler for a RISC CPU, this would be super easy. All instructions are the same length, so I could simply count the number of lines and multiply by the instruction length. Not so on CISC. Each instruction has a different length. I'm not saying this is a negative, but it was an interesting challenge to work around. Variable instruction length can often be an asset as it often results in a smaller code density than on a RISC machine.</p>
<p>Once I understood the architecture sufficiently, I was able to begin working on the executable format- ELF on Linux. I'm not going to go too deeply into ELF here simply because once I begin explaining it, it will take me a while to get back out of it. ELF is actually fairly easy once you know what you're doing, and using the elf.h header is really helpful (its on all Linux systems). The hard part is calculating size and offsets. And the symbol table was really challenging until I found some good resources. The ELF portion of my assembly is the part I'm quite frankly least happiest about. I'm really happy that it works so well, but I feel its a little hacked together as far as the code goes, and there are some known bugs with the symbol and string tables.</p>
<p>My decision to use C was somewhat accidental, though in other ways it was also intentional. I really like how easy C makes it to write structures and binary to files, I like how fast it compiles, and honestly I think it approaches enum's in a much more sane way than C++ does. That said, I also find trying to use strings and build maps and tables to be a major pain in C. At some point I want to redo it in C++ (and hopefully that will not mean starting from scratch). I thought about Rust or another language, but the ability to use elf.h and write them directly to a file is a big thing for me. If you're interested in exploring architecture to that level, C or C++ really are good options.</p>
<p>Once I got things working, for the most part the workflow went pretty well. If you're developing an assembler, the most important thing is the instruction set reference for your CPU (Intel's reference is really good by the way. I do feel there are some gray areas, but for the most part its excellent). Hexdump or any hex editor is really useful until you get to the ELF stage. Once you're there, the readelf tool is really helpful- its good at helping you find most of your ELF issues. Also, once you are at the ELF stage, objdump is really helpful. It shows you the binary and the corresponding assembly (this was a huge help with my location counting errors and my register/prefix mistakes). Another good tool throughout the entire process is the NASM assembler. NASM has an option to generate flat binary files, so using this with hexdump, you can do things such as see how a particular instruction translates. Finally, it helps to have a working knowledge of hexadecimal. Although I've been talking about binary, in the C code and in all the tools I mentioned, you will actually be working with hex.</p>
<p>This has been a long post, and hopefully you found it interesting (congratulations if you made this far :) ). This has honestly been one of my favorite projects mainly because it was a big goal (including in a learning sense) for me, especially after I got my compilers working. I'm currently working on a new compiler, and although it targets multiple platforms, I'm using this project to assemble the code on the x86 platform. More on this later, however.</p>
<p>In the future I'm going to try to write more detailed articles on the Intel architecture, and later the Arm (meaning AArch64- not Arm 7).</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="patrickflynn.co/writing-an-assembler.html">posted at 19:45</a>
                    &nbsp;&middot;&nbsp;<a href="patrickflynn.co/category/programming.html" rel="tag">Programming</a>
                    &nbsp;&middot;
                    &nbsp;<a href="patrickflynn.co/tag/assembly.html" class="tags">Assembly</a>
                    &nbsp;<a href="patrickflynn.co/tag/x86.html" class="tags">x86</a>
                    &nbsp;<a href="patrickflynn.co/tag/programming.html" class="tags">Programming</a>
                </div>
            </article>            <h4 class="date">Sep 26, 2020</h4>

            <article class="post">
                <h2 class="title">
                    <a href="patrickflynn.co/adventures-with-vhdl.html" rel="bookmark" title="Permanent Link to &quot;Adventures with VHDL&quot;">Adventures with VHDL</a>
                </h2>

                
                

                <p>As part of one of my classes I'm taking this semester, I'm learning about VHDL. Actually, I think VHDL is the optional part (so far, I've been learning it pretty much on my own, though the introduction came from the class). I've wanted to learn a hardware descriptor language for some time. I tried Verilog, but I had a hard time finding good tutorials on how to use it, and for some reason I never really looked at VHDL (maybe Verilog scared me away). This may be a slightly unpopular opinion, but I really like VHDL. The reason is the reason why most people dislike it: its basically a subset of Ada, which is a language I'm familiar with.</p>
<p>Anyway, I finally managed to get a simple circuit to run: a full adder, which I eventually made into an 8-bit adder. Its signed, meaning you can use it as either an adder or a subtractor. I'll come back to this in a minute. Here's what it looks like:</p>
<div class="highlight"><pre><span></span><span class="k">library</span> <span class="nn">IEEE</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">IEEE.std_logic_1164.</span><span class="k">all</span><span class="p">;</span>

<span class="c1">-- A single bit full adder</span>
<span class="k">entity</span> <span class="nc">full_adder</span> <span class="k">is</span>
    <span class="k">port</span> <span class="p">(</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ci</span> <span class="o">:</span> <span class="k">in</span> <span class="kt">std_logic</span><span class="p">;</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">co</span> <span class="o">:</span> <span class="k">out</span> <span class="kt">std_logic</span>
    <span class="p">);</span>
<span class="k">end</span> <span class="nc">full_adder</span><span class="p">;</span>

<span class="k">library</span> <span class="nn">IEEE</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">IEEE.std_logic_1164.</span><span class="k">all</span><span class="p">;</span>

<span class="c1">-- An 8-bit adder</span>
<span class="k">entity</span> <span class="nc">adder</span> <span class="k">is</span>
    <span class="k">port</span> <span class="p">(</span>
        <span class="n">vec1</span> <span class="o">:</span> <span class="k">in</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">7</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">vec2</span> <span class="o">:</span> <span class="k">in</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">7</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">out_vec</span> <span class="o">:</span> <span class="k">out</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">7</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">co</span> <span class="o">:</span> <span class="k">out</span> <span class="kt">std_logic</span>
    <span class="p">);</span>
<span class="k">end</span> <span class="nc">adder</span><span class="p">;</span>

<span class="c1">-- The logic for the single-bit adder</span>
<span class="k">architecture</span> <span class="nc">rtl_full_adder</span> <span class="k">of</span> <span class="nc">full_adder</span> <span class="k">is</span>
<span class="k">begin</span>
    <span class="n">s</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">a</span> <span class="k">xor</span> <span class="n">b</span><span class="p">)</span> <span class="k">xor</span> <span class="n">ci</span><span class="p">;</span>
    <span class="n">co</span> <span class="o">&lt;=</span> <span class="p">((</span><span class="n">a</span> <span class="k">xor</span> <span class="n">b</span><span class="p">)</span> <span class="k">and</span> <span class="n">ci</span><span class="p">)</span> <span class="k">or</span> <span class="p">(</span><span class="n">a</span> <span class="k">and</span> <span class="n">b</span><span class="p">);</span>
<span class="k">end</span> <span class="nc">rtl_full_adder</span><span class="p">;</span>

<span class="c1">-- The logic for the 8-bit adder</span>
<span class="k">architecture</span> <span class="nc">rtl_adder</span> <span class="k">of</span> <span class="nc">adder</span> <span class="k">is</span>
    <span class="k">component</span> <span class="nc">full_adder</span>
        <span class="k">port</span> <span class="p">(</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ci</span> <span class="o">:</span> <span class="k">in</span> <span class="kt">std_logic</span><span class="p">;</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">co</span> <span class="o">:</span> <span class="k">out</span> <span class="kt">std_logic</span>
        <span class="p">);</span>
    <span class="k">end</span> <span class="k">component</span><span class="p">;</span>

    <span class="k">signal</span> <span class="n">c</span> <span class="o">:</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">8</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">begin</span>
    <span class="n">op1</span> <span class="o">:</span> <span class="n">full_adder</span> <span class="k">port</span> <span class="k">map</span><span class="p">(</span><span class="n">a</span> <span class="o">=&gt;</span> <span class="n">vec1</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">b</span> <span class="o">=&gt;</span> <span class="n">vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">ci</span> <span class="o">=&gt;</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span> <span class="n">s</span> <span class="o">=&gt;</span> <span class="n">out_vec</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">co</span> <span class="o">=&gt;</span> <span class="n">c</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">op2</span> <span class="o">:</span> <span class="n">full_adder</span> <span class="k">port</span> <span class="k">map</span><span class="p">(</span><span class="n">a</span> <span class="o">=&gt;</span> <span class="n">vec1</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">b</span> <span class="o">=&gt;</span> <span class="n">vec2</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">ci</span> <span class="o">=&gt;</span> <span class="n">c</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">s</span> <span class="o">=&gt;</span> <span class="n">out_vec</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">co</span> <span class="o">=&gt;</span> <span class="n">c</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
    <span class="n">op3</span> <span class="o">:</span> <span class="n">full_adder</span> <span class="k">port</span> <span class="k">map</span><span class="p">(</span><span class="n">a</span> <span class="o">=&gt;</span> <span class="n">vec1</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">b</span> <span class="o">=&gt;</span> <span class="n">vec2</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">ci</span> <span class="o">=&gt;</span> <span class="n">c</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">s</span> <span class="o">=&gt;</span> <span class="n">out_vec</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">co</span> <span class="o">=&gt;</span> <span class="n">c</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
    <span class="n">op4</span> <span class="o">:</span> <span class="n">full_adder</span> <span class="k">port</span> <span class="k">map</span><span class="p">(</span><span class="n">a</span> <span class="o">=&gt;</span> <span class="n">vec1</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">b</span> <span class="o">=&gt;</span> <span class="n">vec2</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">ci</span> <span class="o">=&gt;</span> <span class="n">c</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">s</span> <span class="o">=&gt;</span> <span class="n">out_vec</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">co</span> <span class="o">=&gt;</span> <span class="n">c</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
    <span class="n">op5</span> <span class="o">:</span> <span class="n">full_adder</span> <span class="k">port</span> <span class="k">map</span><span class="p">(</span><span class="n">a</span> <span class="o">=&gt;</span> <span class="n">vec1</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">b</span> <span class="o">=&gt;</span> <span class="n">vec2</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">ci</span> <span class="o">=&gt;</span> <span class="n">c</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">s</span> <span class="o">=&gt;</span> <span class="n">out_vec</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">co</span> <span class="o">=&gt;</span> <span class="n">c</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
    <span class="n">op6</span> <span class="o">:</span> <span class="n">full_adder</span> <span class="k">port</span> <span class="k">map</span><span class="p">(</span><span class="n">a</span> <span class="o">=&gt;</span> <span class="n">vec1</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">b</span> <span class="o">=&gt;</span> <span class="n">vec2</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">ci</span> <span class="o">=&gt;</span> <span class="n">c</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">s</span> <span class="o">=&gt;</span> <span class="n">out_vec</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">co</span> <span class="o">=&gt;</span> <span class="n">c</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span>
    <span class="n">op7</span> <span class="o">:</span> <span class="n">full_adder</span> <span class="k">port</span> <span class="k">map</span><span class="p">(</span><span class="n">a</span> <span class="o">=&gt;</span> <span class="n">vec1</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="n">b</span> <span class="o">=&gt;</span> <span class="n">vec2</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="n">ci</span> <span class="o">=&gt;</span> <span class="n">c</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="n">s</span> <span class="o">=&gt;</span> <span class="n">out_vec</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="n">co</span> <span class="o">=&gt;</span> <span class="n">c</span><span class="p">(</span><span class="mi">7</span><span class="p">));</span>
    <span class="n">op8</span> <span class="o">:</span> <span class="n">full_adder</span> <span class="k">port</span> <span class="k">map</span><span class="p">(</span><span class="n">a</span> <span class="o">=&gt;</span> <span class="n">vec1</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">b</span> <span class="o">=&gt;</span> <span class="n">vec2</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">ci</span> <span class="o">=&gt;</span> <span class="n">c</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">s</span> <span class="o">=&gt;</span> <span class="n">out_vec</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">co</span> <span class="o">=&gt;</span> <span class="n">c</span><span class="p">(</span><span class="mi">8</span><span class="p">));</span>
    <span class="n">co</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="k">end</span> <span class="nc">rtl_adder</span><span class="p">;</span>
</pre></div>


<p>Its actually not as scary as it looks; even without the background, its pretty easy to understand how it works. Binary addition works the same way we humans add numbers- we start with the digit on the right, and work left. The full adder is the smaller circuit that performs the logic operation to add two bits (three if you have carry). In base-2, 0+0 = 0, 0 + 1 = 1, 1 + 0 = 1, 1 + 1 = 0 carry 1, and 1 + 1 + 1 = 1 carry 1 (that extra 1 would be the carry; in all other cases, you can assume its zero). In the 8-bit adder, we simply use the full adder on each bit.</p>
<p>As I mentioned earlier, this implements a signed adder. That means the first bit will be treated as the sign bit. Like all other adders, this uses the 2's complement representation of negative numbers. Because its a signed adder, it also works as a subtractor. Although we often think of subtraction as a separate operation, to a computer there is no such thing. Computers perform addition on signed numbers. So if you wanted to do 10 - 5, to a computer it would be 10 + (-5). For our use, its a complicated way to do it, but it yields the same result.</p>
<p>I think the idea with VHDL testbenches is to test all values, but I wanted to try something once I found VHDL had text IO like other languages. If you use the IEEE standard logic types, you can convert integers to and from the bit vectors. Connect this with some input and output, and you have a simple calculator:</p>
<p><img alt="Photo" src="patrickflynn.co/images/vhdl_calc.png"></p>
<p>And below is the code if you want to try it out. I am using GHDL to build and run this, so here's also the commands I used. Also note, because its 8-bit, you can add numbers until their sum is less than or equal to 127 (binary: 01111111). Anything greater will invert the most significant bit, which will result in a negative number.</p>
<div class="highlight"><pre><span></span>ghdl -a adder.vhdl

ghdl -a --ieee<span class="o">=</span>synopsys test.vhdl
ghdl -e --ieee<span class="o">=</span>synopsys adder_tb
ghdl -r --ieee<span class="o">=</span>synopsys adder_tb --ieee-asserts<span class="o">=</span>disable
</pre></div>


<div class="highlight"><pre><span></span><span class="k">library</span> <span class="nn">IEEE</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">IEEE.std_logic_1164.</span><span class="k">all</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">IEEE.std_logic_signed.</span><span class="k">all</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">IEEE.std_logic_arith.</span><span class="k">all</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">IEEE.numeric_std.</span><span class="k">all</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std.textio.</span><span class="k">all</span><span class="p">;</span>

<span class="c1">--  A testbench has no ports.</span>
<span class="k">entity</span> <span class="nc">adder_tb</span> <span class="k">is</span>
<span class="k">end</span> <span class="nc">adder_tb</span><span class="p">;</span>

<span class="k">architecture</span> <span class="nc">behav</span> <span class="k">of</span> <span class="nc">adder_tb</span> <span class="k">is</span>
    <span class="k">constant</span> <span class="n">WIDTH</span> <span class="o">:</span> <span class="kt">integer</span> <span class="o">:=</span> <span class="mi">8</span><span class="p">;</span>

    <span class="c1">--  Declaration of the component that will be instantiated.</span>
    <span class="k">component</span> <span class="nc">adder</span>
        <span class="k">port</span> <span class="p">(</span>
            <span class="n">vec1</span> <span class="o">:</span> <span class="k">in</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="n">WIDTH</span><span class="o">-</span><span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
            <span class="n">vec2</span> <span class="o">:</span> <span class="k">in</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="n">WIDTH</span><span class="o">-</span><span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
            <span class="n">out_vec</span> <span class="o">:</span> <span class="k">out</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="n">WIDTH</span><span class="o">-</span><span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
            <span class="n">co</span> <span class="o">:</span> <span class="k">out</span> <span class="kt">std_logic</span>
        <span class="p">);</span>
    <span class="k">end</span> <span class="k">component</span><span class="p">;</span>

    <span class="c1">--  Specifies which entity is bound with the component.</span>
    <span class="k">for</span> <span class="n">add0</span><span class="o">:</span> <span class="n">adder</span> <span class="k">use</span> <span class="k">entity</span> <span class="nn">work</span><span class="p">.</span><span class="n">adder</span><span class="p">;</span>
    <span class="k">signal</span> <span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">out_vec</span> <span class="o">:</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="n">WIDTH</span><span class="o">-</span><span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">signal</span> <span class="n">co</span> <span class="o">:</span> <span class="kt">std_logic</span><span class="p">;</span>

<span class="k">begin</span>
    <span class="c1">--  Component instantiation.</span>
    <span class="n">add0</span><span class="o">:</span> <span class="n">adder</span> <span class="k">port</span> <span class="k">map</span> <span class="p">(</span><span class="n">vec1</span> <span class="o">=&gt;</span> <span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span> <span class="o">=&gt;</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">out_vec</span> <span class="o">=&gt;</span> <span class="n">out_vec</span><span class="p">,</span> <span class="n">co</span> <span class="o">=&gt;</span> <span class="n">co</span><span class="p">);</span>

    <span class="c1">--  This process does the real job.</span>
    <span class="k">process</span>

        <span class="c1">-- For input</span>
        <span class="k">variable</span> <span class="n">in_buf1</span> <span class="o">:</span> <span class="n">line</span><span class="p">;</span>
        <span class="k">variable</span> <span class="n">in_buf2</span> <span class="o">:</span> <span class="n">line</span><span class="p">;</span>
        <span class="k">variable</span> <span class="n">in_num1</span> <span class="o">:</span> <span class="kt">integer</span><span class="p">;</span>
        <span class="k">variable</span> <span class="n">in_num2</span> <span class="o">:</span> <span class="kt">integer</span><span class="p">;</span>

        <span class="k">variable</span> <span class="n">val1</span> <span class="o">:</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="n">WIDTH</span><span class="o">-</span><span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">variable</span> <span class="n">val2</span> <span class="o">:</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="n">WIDTH</span><span class="o">-</span><span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>

        <span class="c1">-- For output</span>
        <span class="k">variable</span> <span class="n">l</span> <span class="o">:</span> <span class="n">line</span><span class="p">;</span>
        <span class="k">variable</span> <span class="n">out_num</span> <span class="o">:</span> <span class="kt">integer</span><span class="p">;</span>
    <span class="k">begin</span>

        <span class="c1">-- Get all the input</span>
        <span class="n">write</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="kt">String</span><span class="p">&#39;(</span><span class="s">&quot;Enter two numbers&quot;</span><span class="p">));</span>
        <span class="n">writeline</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>

        <span class="n">readline</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">in_buf1</span><span class="p">);</span>
        <span class="n">read</span><span class="p">(</span><span class="n">in_buf1</span><span class="p">,</span> <span class="n">in_num1</span><span class="p">);</span>

        <span class="n">readline</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">in_buf2</span><span class="p">);</span>
        <span class="n">read</span><span class="p">(</span><span class="n">in_buf2</span><span class="p">,</span> <span class="n">in_num2</span><span class="p">);</span>

        <span class="n">val1</span> <span class="o">:=</span> <span class="n">conv_std_logic_vector</span><span class="p">(</span><span class="n">in_num1</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">);</span>
        <span class="n">val2</span> <span class="o">:=</span> <span class="n">conv_std_logic_vector</span><span class="p">(</span><span class="n">in_num2</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">);</span>

        <span class="k">wait</span> <span class="k">for</span> <span class="mi">50</span> <span class="n">ns</span><span class="p">;</span>

        <span class="c1">-- Do the calculations</span>
        <span class="n">vec1</span> <span class="o">&lt;=</span> <span class="n">val1</span><span class="p">;</span>
        <span class="n">vec2</span> <span class="o">&lt;=</span> <span class="n">val2</span><span class="p">;</span>
        <span class="k">wait</span> <span class="k">for</span> <span class="mi">50</span> <span class="n">ns</span><span class="p">;</span>

        <span class="c1">-- Output everything</span>
        <span class="n">write</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="kt">String</span><span class="p">&#39;(</span><span class="s">&quot;Num1: &quot;</span><span class="p">));</span>
        <span class="n">write</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">to_bitvector</span><span class="p">(</span><span class="n">val1</span><span class="p">));</span>
        <span class="n">write</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="kt">String</span><span class="p">&#39;(</span><span class="s">&quot; | Num2: &quot;</span><span class="p">));</span>
        <span class="n">write</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">to_bitvector</span><span class="p">(</span><span class="n">val2</span><span class="p">));</span>
        <span class="n">writeline</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>

        <span class="n">out_num</span> <span class="o">:=</span> <span class="n">conv_integer</span><span class="p">(</span><span class="n">out_vec</span><span class="p">);</span>

        <span class="n">write</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="kt">String</span><span class="p">&#39;(</span><span class="s">&quot;&quot;</span><span class="p">));</span>
        <span class="n">writeline</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
        <span class="n">write</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="kt">String</span><span class="p">&#39;(</span><span class="s">&quot;Result: &quot;</span><span class="p">));</span>
        <span class="n">write</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">out_num</span><span class="p">);</span>
        <span class="n">writeline</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>

        <span class="n">write</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="kt">String</span><span class="p">&#39;(</span><span class="s">&quot;Output: &quot;</span><span class="p">));</span>
        <span class="n">write</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">to_bitvector</span><span class="p">(</span><span class="n">out_vec</span><span class="p">));</span>
        <span class="n">writeline</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>

        <span class="k">wait</span><span class="p">;</span>
    <span class="k">end</span> <span class="k">process</span><span class="p">;</span>

<span class="k">end</span> <span class="nc">behav</span><span class="p">;</span>
</pre></div>
                <div class="clear"></div>

                <div class="info">
                    <a href="patrickflynn.co/adventures-with-vhdl.html">posted at 15:30</a>
                    &nbsp;&middot;&nbsp;<a href="patrickflynn.co/category/programming.html" rel="tag">Programming</a>
                    &nbsp;&middot;
                    &nbsp;<a href="patrickflynn.co/tag/programming.html" class="tags">Programming</a>
                    &nbsp;<a href="patrickflynn.co/tag/vhdl.html" class="tags">VHDL</a>
                </div>
            </article>

                <div class="clear"></div>
                <div class="pages">

                    <a href="patrickflynn.co/" class="prev_page">&larr;&nbsp;Previous</a>
                    <a href="patrickflynn.co/blog_index3" class="next_page">Next&nbsp;&rarr;</a>
                    <span>Page 2 of 5</span>
                </div>

            <div class="clear"></div>
            <footer>
                <p>
                <a href="https://github.com/jody-frankowski/blue-penguin">Blue Penguin</a> Theme
                &middot;
                Powered by <a href="http://getpelican.com">Pelican</a>
            </footer>
        </div>
        <div class="clear"></div>
    </div>
    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-213498014-7");
    pageTracker._trackPageview();
    } catch(err) {}</script>
</body>
</html>